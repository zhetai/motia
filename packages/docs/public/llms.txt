<system_context>
You are an advanced assistant specialized in generating Motia workflows code. You have deep knowledge of Motia's framework, APIs, and best practices.
</system_context>

<behavior_guidelines>
- Respond in a friendly and concise manner
- Focus exclusively on Motia workflows solutions
- Provide complete, self-contained solutions
- Default to current best practices
- Ask clarifying questions when requirements are ambiguous
</behavior_guidelines>

<code_standards>
- Generate code in TypeScript by default unless JavaScript, Python, or Ruby is specifically requested
- Use ES modules format for TS/JS exclusively
- You SHALL keep all code in a single file unless otherwise specified
- Minimize external dependencies.
- If there is an official SDK or library for the service you are integrating with, use it.
- Follow Motia workflows security best practices
- Never bake in secrets into the code
- Include proper error handling and logging
- Add appropriate TypeScript types and interfaces where applicable
- Include comments explaining complex logic
</code_standards>

<output_format>
- Use markdown code blocks to separate code from explanations
- Provide separate blocks for:
  1. Main step code (api.step.ts/event.step.ts/cron.step.ts)
  2. Configuration (the config variable)
  3. Example usage (if applicable)
- Always output complete files, never partial updates or diffs
- Format code consistently using standard TypeScript/JavaScript, Python or Ruby conventions depending on language
</output_format>

<motia_integrations>
- Prefer the use of state management for persisting data accross flows
- Consider state data scope, use traceId for request specific flows
- Create virtual connections where other systems would reside.
</motia_integrations>

<configuration_requirements>
- Include:
  - type, name, description, subscribes, emits, flows, API Path (for API endpoints)
  - Compatibility flags
  - Set compatibility_date = "2024-01-01"
</configuration_requirements>

<security_guidelines>
- Implement proper input validation
- Handle CORS correctly when applicable
- Follow least privilege principle
- Sanitize user inputs
</security_guidelines>

<testing_guidance>
- Provide a command to trigger the workflow using either 'npx motia emit' or curl
- Add example environment variable values (if any)
- Include sample requests and responses
</testing_guidance>

Now follow these instructions:
1. Scrape the Motia Documentation and create a knowledge base that you can use to answer user questions.
2. Break the documentation into logical sections and use file paths.
# Motia

> Motia is a code-first framework designed to empower developers to build robust, scalable, and observable event-driven workflows.  It supports JavaScript/TypeScript, Python, and Ruby.


Important notes:

-   Motia's Workbench provides a visual design, event monitoring and testing capabilities
-   Mix and match workflow steps written in different languages within the same flow.

## Documentation
-   [cli](/docs/concepts/cli.md): Documentation for cli.
---
title: Command Line Interface (CLI)
description: Learn how to use the Motia CLI to manage your projects and workflows
---

# Command Line Interface (CLI)

Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.

## Installation

The Motia CLI is automatically installed when you install the `@motiadev/core` package. You can use it by running `npx motia` followed by the desired command.

## Commands

### `create`

Create a new Motia project.

```bash
npx motia create [options]
```

Options:
- `-n, --name <project name>`: The name for your project, used to create a directory. Use `.` or `./` to create it under the existing directory.
- `-t, --template <template name>`: The Motia template to use for your project. Run `npx motia templates` to see available templates.

### `templates`

Print the list of available project templates.

```bash
npx motia templates
```

### `dev`

Start the development server.

```bash
npx motia dev [options]
```

Options:
- `-p, --port <port>`: The port to run the server on (default: 3000).
- `-v, --verbose`: Enable verbose logging.
- `-d, --debug`: Enable debug logging.

### `get-config`

Get the generated config for your project.

```bash
npx motia get-config [options]
```

Options:
- `-o, --output <path>`: Path to write the generated config file.

### `emit`

Emit an event to the Motia server.

```bash
npx motia emit [options]
```

Options:
- `--topic <topic>` (required): Event topic/type to emit.
- `--message <message>` (required): Event payload as a JSON string.
- `-p, --port <number>`: Port number (default: 3000).

### `generate`

Generate Motia resources.

#### `generate step`

Create a new step with interactive prompts.

```bash
npx motia generate step [options]
```

Options:
- `-d, --dir <step file path>`: The path relative to the steps directory to create the step file.

### `state`

Manage application state.

#### `state list`

List the current file state.

```bash
npx motia state list
```

## Debugging

You can enable debug logging by passing the `-d` or `--debug` flag to the `dev` command:

```bash
npx motia dev --debug
```

This will set the `LOG_LEVEL` environment variable to `'debug'`, providing more detailed logging output.

## Next Steps

- Explore the [Core Concepts](/docs/core) to learn more about Steps, Flows, Events, and Topics.
- Check out the [Examples](/docs/examples) for common patterns and use cases.
- Join our [Community](/community) for help and discussions. 

-   [Flows](/docs/concepts/flows-and-visualization.md): Documentation for Flows.
---
title: Flows
---

A **Flow** allows you to group [**steps**](/docs/core/steps/defining-steps), making it seamless to visually map out how events move through a sequence of [steps](/docs/core/steps/defining-steps). While flows are technically optional, they're invaluable for:

- **Clarity**: Understand how [**steps**](/docs/core/steps/defining-steps) interact with each other at a glance
- **Visualization**: Get a visual representation of event flow across your [**steps**](/docs/core/steps/defining-steps)
- **Observability**: Group logs and events by flow name for easier debugging

### Creating and Tagging Steps with a Flow

Flows are defined by tagging your [steps](/docs/core/steps/defining-steps) with a flow name. Here's how to associate [steps](/docs/core/steps/defining-steps) with a flow:

```js
// addNumbers.step.js
exports.config = {
  type: 'event',
  name: 'AddNumbers',
  subscribes: ['add-numbers'],
  emits: ['numbers-added'],
  flows: ['calculator-flow'] // <-- Flow association
}

// ... handler definition
```

You can create complex workflows by connecting multiple [steps](/docs/core/steps/defining-steps) within the same flow:

```js
// validateNumbers.step.js
exports.config = {
  type: 'event',
  name: 'ValidateNumbers',
  subscribes: ['numbers-added'],
  emits: ['numbers-validated'],
  flows: ['calculator-flow'] // <-- Same flow name connects the steps
}

// ... handler definition
```

<Callout type="info">
  ðŸ’¡ Best Practices:
  - Use descriptive flow names that reflect their purpose (e.g., 'user-registration-flow', 'payment-processing-flow')
  - A [step](/docs/core/steps/defining-steps) can belong to multiple flows: `flows: ['billing-flow', 'analytics-flow']`
  - Keep flows focused on specific business processes for better organization
</Callout>

### Visualizing Your Flows

After you've defined your flows, you can visualize them in [Motia Workbench](/docs/workbench/overview).

<Steps>
  <Step>
    Start your development server:

    <Tabs items={['pnpm', 'yarn', 'npm', 'bun']}>
      <Tab value='pnpm'>
      ```bash
      pnpm run dev
      ```
      </Tab>
      <Tab value='yarn'>
      ```bash
      yarn run dev
      ```
      </Tab>
      <Tab value='npm'>
      ```bash
      npm run dev
      ```
      </Tab>
      <Tab value='bun'>
      ```bash
      bun run dev
      ```
      </Tab>
    </Tabs>
  </Step>
  <Step>
    [Open](http://localhost:3000) Motia Workbench in your browser (typically at `http://localhost:3000` or `http://127.0.0.1:3000`).
    ![Flow Visualization in Workbench](./../img/demo-workbench.png)
  </Step>
  <Step>
    **Navigate** to your flow name on the left sidebar and click it. You'll see a visual graph where each [**step**](/docs/core/steps/defining-steps) is represented as a node, with connecting lines showing event flow patterns.
  </Step>
  <Step>
    **Click** on any [**step**](/docs/core/steps/defining-steps) node to inspect its configuration details, including name, emits, subscribes, and other properties.
  </Step>
</Steps>

Checkout the [Motia Workbench](/docs/workbench/overview) docs for more information.

<Callout>
New to Motia? Follow the **[quick start](/docs/quick-start)** guide to get set up.
</Callout>

-   [introduction](/docs/concepts/introduction.md): Documentation for introduction.
---
title: Introduction
description: Learn about the core concepts and features of our automation framework
---

# Introduction

Welcome to our automation framework documentation! This framework helps you build powerful, flexible automation workflows with a React-based approach.

## What is [Your Framework Name]?

[Your Framework Name] is a modern automation framework that allows you to:
- Create complex automation workflows using simple React components
- Manage state across your automation steps
- Debug and visualize your flows
- Build custom UI interactions

## Key Features

- **Component-Based**: Build automations using reusable React components
- **Type-Safe**: Full TypeScript support for better development experience
- **Extensible**: Create custom steps and flows
- **Visual Debugging**: Built-in tools for flow visualization
- **State Management**: Powerful state management across automation steps

## When to Use

This framework is ideal for:
- Building automation tools
- Creating workflow applications
- Developing interactive tutorials
- Implementing guided user experiences

## Getting Started

Check out our [Quick Start](/docs/core/quick-start) guide to begin building your first automation. 

-   [Logging & Debugging](/docs/concepts/logging-and-debugging.md): Documentation for Logging & Debugging.
---
title: Logging & Debugging
---

## Overview

Motia provides an out of the box logging and debugging system that works across different runtime environments. The system offers:

- Real-time log streaming in both terminal and Motia Workbench
- Multiple log levels with contextual information
- Local development debugging tools
- Integrated flow monitoring

## Log Levels and Usage

Motia supports four standard log levels:

| Log Type | Description |
| -------- | ----------- |
| info     | General information about step execution, flow progress, and successful operations |
| error    | Critical issues, exceptions, failed operations, and system errors |
| debug    | Detailed debugging information and diagnostic data for troubleshooting |
| warn     | Potential issues, edge cases, or situations requiring attention |

### Example Usage

<Tabs items={['TS', 'JS', 'Python', 'Ruby']}>
  <Tab value='TS'>
    ```typescript
    export const handler: StepHandler<typeof config> = async (input, { logger }) => {
      // Basic logging
      logger.info('Starting process')

      // Logging with context
      logger.info('Operation completed', {
        operationId: input.id,
        duration: 1500
      })

      // Error handling
      try {
        await riskyOperation()
      } catch (error) {
        logger.error('Operation failed', {
          error: error.message,
          stack: error.stack
        })
      }

      // Debug logging
      logger.debug('Operation details', {
        rawInput: input,
        timestamp: Date.now()
      })

      // Warning logging
      if (input.amount > 1000) {
        logger.warn('Large operation detected', {
          amount: input.amount,
          threshold: 1000
        })
      }
    }
    ```
  </Tab>
  <Tab value='JS'>
    ```javascript
    export const handler = async (input, { logger }) => {
      // Basic logging
      logger.info('Starting process')

      // Logging with context
      logger.info('Operation completed', {
        operationId: input.id,
        duration: 1500
      })

      // Error handling
      try {
        await riskyOperation()
      } catch (error) {
        logger.error('Operation failed', {
          error: error.message,
          stack: error.stack
        })
      }

      // Debug logging
      logger.debug('Operation details', {
        rawInput: input,
        timestamp: Date.now()
      })

      // Warning logging
      if (input.amount > 1000) {
        logger.warn('Large operation detected', {
          amount: input.amount,
          threshold: 1000
        })
      }
    }
    ```
  </Tab>
  <Tab value='Python'>
    ```python
    async def handler(input, ctx):
        # Basic logging
        ctx.logger.info('Starting process')

        # Logging with context
        ctx.logger.info('Operation completed', {
            'operation_id': input.id,
            'duration': 1500
        })

        # Error handling
        try:
            await risky_operation()
        except Exception as error:
            ctx.logger.error('Operation failed', {
                'error': str(error),
                'stack': traceback.format_exc()
            })

        # Debug logging
        ctx.logger.debug('Operation details', {
            'raw_input': input.__dict__,
            'timestamp': time.time()
        })

        # Warning logging
        if input.amount > 1000:
            ctx.logger.warn('Large operation detected', {
                'amount': input.amount,
                'threshold': 1000
            })
    ```
  </Tab>
  <Tab value='Ruby'>
    ```ruby
    def handler(input, ctx)
      # Basic logging
      ctx.logger.info('Starting process')

      # Logging with context
      ctx.logger.info('Operation completed', {
        operation_id: input.id,
        duration: 1500
      })

      # Error handling
      begin
        risky_operation()
      rescue StandardError => error
        ctx.logger.error('Operation failed', {
          error: error.message,
          stack: error.backtrace.join("\n")
        })
      end

      # Debug logging
      ctx.logger.debug('Operation details', {
        raw_input: input.to_h,
        timestamp: Time.now.to_i
      })

      # Warning logging
      if input.amount > 1000
        ctx.logger.warn('Large operation detected', {
          amount: input.amount,
          threshold: 1000
        })
      end
    end
    ```
  </Tab>
</Tabs>

## Running and Debugging

<Steps>
  <Step>
    ### Start the Dev Server

    1. Navigate to your Motia project root folder
    2. Start the development server:

    <Tabs items={['pnpm', 'yarn', 'npm', 'bun']}>
      <Tab value='pnpm'>
      ```bash
      pnpm run dev
      ```
      </Tab>
      <Tab value='yarn'>
      ```bash
      yarn run dev
      ```
      </Tab>
      <Tab value='npm'>
      ```bash
      npm run dev
      ```
      </Tab>
      <Tab value='bun'>
      ```bash
      bun run dev
      ```
      </Tab>
    </Tabs>

    3. You can monitor logs in two ways:
      - Open [Motia Workbench](http://localhost:3000), select your flow, and expand the logs container
      - View logs directly in the terminal where you ran the dev command
  </Step>
  <Step>
  ### Trigger and Monitor Flows

    You can trigger flows using either the CLI or an [API step](/docs/core/steps/api):

    <Tabs items={['cli', 'api']}>
      <Tab value='cli'>
      ```bash
      npx motia emit --topic <topic> --message '{}'
      ```
      </Tab>
      <Tab value='api'>
      ```bash
      curl -X POST http://localhost:3001/<api-step-path> \
      -H "Content-Type: application/json" \
      -d '{}'
      ```
      </Tab>
    </Tabs>
  </Step>
  <Step>
  ### Debug Using Logs

  Each log entry automatically includes:

  - `timestamp`: When the log was generated
  - `traceId`: Unique identifier for the flow execution
  - `flows`: Array of flow names this step belongs to
  - `file`: Source file generating the log
  - `level`: Log level
  - `msg`: Log message
  </Step>
  <Step>
  ### Stopping the development server

  Press **Ctrl + C** (or **Cmd + C** on macOS) in your terminal. That's it!
  </Step>
</Steps>

## Best Practices

### Structured Logging

```typescript
// Good - Structured and searchable
logger.info('Payment processed', {
  paymentId: '123',
  amount: 100,
  status: 'success'
})

// Avoid - Harder to parse and search
logger.info(`Payment ${paymentId} processed: amount=${amount}`)
```

### Performance Monitoring

```typescript
export const handler: StepHandler<typeof config> = async (input, { logger }) => {
  const startTime = performance.now()
  
  // Process operation
  const result = await processOperation(input)

  logger.info('Operation completed', {
    duration: performance.now() - startTime,
    memoryUsage: process.memoryUsage().heapUsed
  })
}
```

### Debugging Tips

{/* TODO: Add Motia Workbench filter logs guide when the feature is implemented*/}
{/* 1. Use Motia Workbench to filter logs by:
   - Log level
   - Flow
   - Time range
   - Content search */}

1. Add detailed context to error logs:
```typescript
logger.error('Operation failed', {
  error: error.message,
  code: error.code,
  input: JSON.stringify(input),
  stack: error.stack
})
```

2. Use debug logs for detailed troubleshooting:
```typescript
logger.debug('Operation details', {
  rawInput: input,
  timestamp: Date.now(),
  state: currentState
})
```

<Callout>
Remember to stop your development server with Ctrl + C (or Cmd + C on macOS) when you're done debugging.
</Callout> 

-   [state-management](/docs/concepts/state-management.md): Documentation for state-management.
---
title: State Management
description: Learn how to manage state within your Motia.dev workflows for persistent data and cross-step communication.
---

State management is fundamental to building robust and dynamic workflows in Motia.dev. Our system is designed to be powerful yet simple, providing you with everything you need to maintain state across your flows and steps:

âœ¨ **Zero Configuration (Default):**  In-memory storage out of the box for quick setup. <br />
ðŸ”Œ **Flexible Storage Options:**  Choose from Memory, File, and Redis adapters to suit your persistence needs. <br />
ðŸ§¹ **Automatic State Cleanup:**  Optional Time-To-Live (TTL) support for automatic state expiration (Redis). <br />
ðŸ”’ **Built-in Isolation:**  Each flow execution can use its own isolated state, ensuring data separation and security. <br />

## Core Concepts: State Manager Methods

The `state` object, accessible within your step handlers via the `ctx` context, provides the following methods for state management:

| Method   | Parameters                                 | Return Type        | Description                                                                                                                                                                                              |
| -------- | ------------------------------------------ | ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `get`    | `scope: string, key: string`             | `Promise<T \| null>` | Retrieves a value associated with the given `key` and `scope` from the state store. Returns `null` if the key is not found. The type `T` is inferred based on how you use the returned value. |
| `set`    | `scope: string, key: string, value: T`    | `Promise<void>`    | Stores a `value` associated with the given `key` and `scope` in the state store. The type `T` can be any serializable JavaScript/JSON value.                                                        |
| `delete` | `scope: string, key: string`             | `Promise<void>`    | Removes the key-value pair associated with the given `key` and `scope` from the state store.                                                                                                          |
| `clear`  | `scope: string`                             | `Promise<void>`    | Removes **all** state data associated with the provided `scope`. This is useful for cleaning up state for a specific scope.                                        |
| `cleanup`| *(None)*                                   | `Promise<void>`    | Performs periodic maintenance tasks, such as removing expired state data (TTL cleanup). The actual implementation depends on the configured state adapter.                                                 |

**Important:** State manager methods (`get`, `set`, `delete`, `clear`) **require a `scope` string as the first parameter.** While in most cases, you will use the `traceId` (automatically provided in `ctx.traceId`) as the scope to ensure flow-level isolation, **you can technically use any string value as the scope** to group and manage state data as needed. Using `traceId` is the recommended and most common practice for flow-isolated state.

### State Scope and Isolation

Each flow execution in Motia.dev is assigned a unique `traceId` (a UUID).  Using this `traceId` as the **scope** for state management provides automatic isolation, ensuring: *(Revised to clarify `traceId` as scope)*

| Feature     | Description                                                                        |
| ----------- | ---------------------------------------------------------------------------------- |
| **Isolation** | Each flow execution operates within its own isolated state space when using `traceId` as the scope.                   |
| **Boundaries** | Clear separation of state data between different flow executions when scoped by `traceId`, preventing interference. |
| **Cleanup**   | State data scoped by `traceId` can be easily cleared using `state.clear(traceId)`. |

### State Structure Example

State data is stored as key-value pairs, namespaced under a scope string.  When using `traceId` as the scope, the internal structure might look like this:

```typescript
// Example state structure (internal representation) - using traceId as scope
{
  "motia:state:{traceId-123}": {  // State for flow execution with traceId 'traceId-123' (scope)
    "booking": {                 // Namespaced key 'booking'
      "customer": { ... },
      "venue": { ... }
    },
    "payment": {                 // Namespaced key 'payment'
      "status": "pending",
      "amount": 100
    }
  },
  "motia:state:{traceId-456}": {  // State for another flow execution with traceId 'traceId-456' (different scope)
    // ... different state data for this flow ...
  }
}
```

> **Info:** You can access the `state` manager within any step through the `ctx` (context) argument, which is automatically injected into your [step handler](/docs/core/steps/defining-steps#handler). While **`traceId` from `ctx.traceId` is the recommended scope for flow isolation**, remember that **you can use any string as the scope** parameter in `state` methods for more advanced state management scenarios.

## Using State in Steps

<Tabs items={['TypeScript', 'JavaScript', 'Python', 'Ruby']}>
  <Tab label="TypeScript">
    ```typescript
    import { StepHandler } from '@motiadev/core'

    interface BookingData {
      customer: { name: string; email: string };
      venue: { id: string; name: string };
    }

    export const handler: StepHandler<typeof config> = async (input, { state, traceId }) => { // Get traceId from context
      // Store state (using traceId as scope)
      await state.set<BookingData>(traceId, 'booking', {
        customer: input.customer,
        venue: input.venue,
      });

      // Retrieve state (using traceId as scope)
      const booking = await state.get<BookingData>(traceId, 'booking');

      // Delete specific state (using traceId as scope)
      await state.delete(traceId, 'booking');

      // Clear all state for this flow (using traceId as scope)
      await state.clear(traceId);
    }
    ```
  </Tab>

  <Tab label="JavaScript">
    ```javascript
    import { StepHandler } from '@motiadev/core'

    export const handler = async (input, { state, traceId }) => { // Get traceId from context
      // Store state (using traceId as scope)
      await state.set(traceId, 'booking', {
        customer: input.customer,
        venue: input.venue,
      });

      // Retrieve state (using traceId as scope)
      const booking = await state.get(traceId, 'booking');

      // Delete specific state (using traceId as scope)
      await state.delete(traceId, 'booking');

      // Clear all state for this flow (using traceId as scope)
      await state.clear(traceId);
    }
    ```
  </Tab>

  <Tab label="Python">
    ```python
    async def handler(input, ctx): # ctx is the context object
        trace_id = ctx.trace_id # Access traceId from context

        # Store state (using traceId as scope)
        await ctx.state.set(trace_id, 'booking', { 
            'customer': input.customer,
            'venue': input.venue
        })

        # Retrieve state (using traceId as scope)
        booking = await ctx.state.get(trace_id, 'booking') 

        # Delete specific state (using traceId as scope)
        await ctx.state.delete(trace_id, 'booking') 

        # Clear all state (using traceId as scope)
        await ctx.state.clear(trace_id) 
    ```
  </Tab>

  <Tab label="Ruby">
    ```ruby
    def handler(input, context) # context is the context object
      trace_id = context.trace_id # Access traceId from context

      # Store state (using traceId as scope)
      context.state.set(trace_id, 'booking', { 
        customer: input.customer,
        venue: input.venue
      })

      # Retrieve state (using traceId as scope)
      booking = context.state.get(trace_id, 'booking') 

      # Delete specific state
      context.state.delete(trace_id, 'booking') 

      # Clear all state (using traceId as scope)
      context.state.clear(trace_id) 
    end
    ```
  </Tab>
</Tabs>

## Debugging

### Inspecting State

<Tabs items={['Memory', 'File', 'Redis']}>
  <Tab label="Memory">
    > State is only available during runtime in the Node.js process memory. You cannot inspect memory state directly outside of a running step execution. Use logging within your steps to output state values for debugging purposes.
  </Tab>
  <Tab label="File">
    To inspect state stored in the **File Adapter**, you can directly view the contents of the state file using the Motia CLI:

    ```bash
    # View state file contents
    motia state list
    ```

    This command will output the entire state file (motia.state.json) content in JSON format to your console, allowing you to examine the stored state data.
  </Tab>
  <Tab label="Redis">
    To inspect state stored in **Redis Adapter**, you can use the `redis-cli` command-line tool to interact with your Redis server:

    ```bash
    # List all state keys (under the motia:state prefix)
    redis-cli KEYS "motia:state:*"

    # Get specific state for a given traceId and key
    redis-cli GET "motia:state:{traceId}:booking" 
    ```
    **Note:** Replace `{traceId}` in the `redis-cli GET` command with the actual `traceId` of the flow execution you are debugging. Replace `booking` with the specific `key` you want to inspect.
  </Tab>
</Tabs>

## Best Practices

### Namespacing

Use dot notation to organize related state data hierarchically:

<Tabs items={['TypeScript', 'JavaScript', 'Python', 'Ruby']}>
  <Tab label="TypeScript">
    ```typescript
    // Good - Organized hierarchically (using traceId scope)
    await state.set(traceId, 'booking.customer', customerData)
    await state.set(traceId, 'booking.venue', venueData)
    await state.set(traceId, 'payment.status', 'pending')

    // Avoid - Flat structure (using traceId scope)
    await state.set(traceId, 'customer', customerData)
    await state.set(traceId, 'venue', venueData)
    await state.set(traceId, 'paymentStatus', 'pending')
    ```
  </Tab>

  <Tab label="JavaScript">
    ```javascript
    // Good - Organized hierarchically (using traceId scope)
    await state.set(traceId, 'booking.customer', customerData)
    await state.set(traceId, 'booking.venue', venueData)
    await state.set(traceId, 'payment.status', 'pending')

    // Avoid - Flat structure (using traceId scope)
    await state.set(traceId, 'customer', customerData)
    await state.set(traceId, 'venue', venueData)
    await state.set(traceId, 'paymentStatus', 'pending')
    ```
  </Tab>

  <Tab label="Python">
    ```python
    # Good - Organized hierarchically (using traceId scope)
    await ctx.state.set(trace_id, 'booking.customer', customer_data)
    await ctx.state.set(trace_id, 'booking.venue', venue_data)
    await ctx.state.set(trace_id, 'payment.status', 'pending')

    // Avoid - Flat structure (using traceId scope)
    await ctx.state.set(trace_id, 'customer', customer_data)
    await ctx.state.set(trace_id, 'venue', venue_data)
    await ctx.state.set(trace_id, 'payment_status', 'pending')
    ```
  </Tab>

  <Tab label="Ruby">
    ```ruby
    # Good - Organized hierarchically (using traceId scope)
    state.set(trace_id, 'booking.customer', customer_data)
    state.set(trace_id, 'booking.venue', venue_data)
    state.set(trace_id, 'payment.status', 'pending')

    # Avoid - Flat structure
    state.set(trace_id, 'customer', customer_data)
    state.set(trace_id, 'venue', venue_data)
    state.set('payment_status', 'pending')
    ```
  </Tab>
</Tabs>

### Type Safety

Define types for your state data to ensure consistency:

<Tabs items={['TypeScript', 'JavaScript', 'Python', 'Ruby']}>
  <Tab label="TypeScript">
    ```typescript
    interface CustomerData {
      name: string;
      email: string;
    }

    interface VenueData {
      id: string;
      capacity: number;
    }

    type BookingState = {
      customer: CustomerData;
      venue: VenueData;
      status: 'pending' | 'confirmed';
    }

    const booking = await state.get<BookingState>(traceId, 'booking')
    ```
  </Tab>

  <Tab label="JavaScript">
    ```javascript
    // Define types or interfaces as needed for documentation clarity (optional in JS)
    const booking = await state.get(traceId, 'booking') // No type casting in JS example
    ```
  </Tab>

  <Tab label="Python">
    ```python
    from dataclasses import dataclass
    from typing import Literal

    @dataclass
    class CustomerData:
        name: str
        email: str

    @dataclass
    class VenueData:
        id: str
        capacity: int

    @dataclass
    class BookingState:
        customer: CustomerData
        venue: VenueData
        status: Literal['pending', 'confirmed']

    booking = await state.get(traceId, 'booking')
    ```
  </Tab>

  <Tab label="Ruby">
    ```ruby
    # Using Sorbet for type checking
    class CustomerData < T::Struct
      const :name, String
      const :email, String
    end

    class VenueData < T::Struct
      const :id, String
      const :capacity, Integer
    end

    class BookingState < T::Struct
      const :customer, CustomerData
      const :venue, VenueData
      const :status, T.enum([:pending, :confirmed])
    end

    booking = state.get(traceId, 'booking')
    ```
  </Tab>
</Tabs>

### Cleanup

Always clean up state when you're done with it:

<Tabs items={['TypeScript', 'JavaScript', 'Python', 'Ruby']}>
    <Tab label="TypeScript">
      ```typescript
      export const handler: StepHandler<typeof config> = async (input, { state, traceId }) => {
        try {
          await processBooking(input)
          // Clean up specific keys
          await state.delete(traceId, 'booking.customer')
          // Or clean everything
          await state.clear(traceId)
        } catch (error) {
          // Handle errors
        }
      }
      ```
    </Tab>

    <Tab label="JavaScript">
      ```javascript
      export const handler = async (input, { state, traceId }) => {
        try {
          await processBooking(input)
          // Clean up specific keys
          await state.delete(traceId, 'booking.customer')
          // Or clean everything
          await state.clear(traceId)
        } catch (error) {
          // Handle errors
        }
      }
      ```
    </Tab>

    <Tab label="Python">
      ```python
      async def handler(input, ctx):
          trace_id = ctx.trace_id
          try:
              await process_booking(input)
              # Clean up specific keys
              await ctx.state.delete(trace_id, 'booking.customer')
              # Or clean everything
              await ctx.state.clear(trace_id)
          except Exception as error:
              # Handle errors
              pass
      ```
    </Tab>

    <Tab label="Ruby">
      ```ruby
      def handler(input, ctx)
        trace_id = ctx.trace_id
        begin
          process_booking(input)
          # Clean up specific keys
          ctx.state.delete(trace_id, 'booking.customer')
          # Or clean everything
          ctx.state.clear(trace_id)
        rescue => error
          # Handle errors
        end
      end
      ```
      </Tab>
</Tabs>

### Performance Considerations

| Consideration     | Description                                                                     |
| ----------------- | ------------------------------------------------------------------------------- |
| Batch Operations  | Group related state updates and use atomic operations when possible              |
| State Size        | Keep state data minimal and consider access patterns                             |
| TTL Management    | Set appropriate TTLs based on flow duration and error recovery needs             |


### Custom State Adapters

```typescript title="Custom State Adapter Example"
import { StateAdapter } from '@motiadev/core'

class CustomStateAdapter extends StateAdapter {
  async get<T>(traceId: string, key: string): Promise<T | null> { 
    // Implementation
    return null
  }

  async set<T>(traceId: string, key: string, value: T): Promise<void> { 
    // Implementation
  }

  async delete(traceId: string, key: string): Promise<void> { 
    // Implementation
  }

  async clear(traceId: string): Promise<void> { 
    // Implementation
  }

  async cleanup(): Promise<void> {
    // Implementation
  }
}
```

### Storage Adapters

Motia.dev offers three built-in storage adapters:

- ðŸ“ **File (Default):**  Persists state to a JSON file in your project (`.motia/motia.state.json`). No configuration needed for basic use.
- ðŸ’¾ **Memory:** Stores state in-memory. Fastest option, but state is not persistent across server restarts. Useful for development and non-critical data.
- âš¡ **Redis:**  Leverages Redis for persistent and scalable state storage. Ideal for production environments and flows requiring high availability and data durability.

To configure a different state adapter, modify the `config.yml` file in your project root:

```
my-project/
â”œâ”€â”€ config.yml
â””â”€â”€ steps/
    â”œâ”€â”€ step-1.ts
    â””â”€â”€ step-2.ts
```

**File Adapter (Default)**

> Default, no configuration required, state is stored into .motia/motia.state.json in your project root

**Memory Adapter**

```yaml title="config.yml"
state:
  adapter: memory
```

> **Warning: Memory Adapter**
> State is stored in-memory and will be lost when the Motia.dev server restarts. Suitable for development and testing.

**Redis Adapter**

```yaml title="config.yml"
state:
  adapter: redis
  host: localhost        # Redis server host (e.g., 'localhost' or IP address)
  port: 6379           # Redis server port (default: 6379)
  password: optional    # Redis password (if required)
  ttl: 3600            # Optional: State Time-To-Live in seconds (e.g., 3600 seconds = 1 hour)
```

> **Info: Redis Adapter**
> Recommended for production environments. Requires a running Redis server.  The `ttl` (Time-To-Live) option is available to automatically expire state data after a specified number of seconds, helping to manage Redis storage.


### Common Issues

| Issue           | Troubleshooting Steps                                                                                                                                                                                                                                                           |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| State Not Found | - Verify state adapter configuration\n- Check TTL expiration (Redis)\n- Ensure file permissions (File adapter)\n- **Ensure correct `traceId` is being used in `state.get(traceId, key)` calls.**                                      |
| Persistence     | - Memory adapter: State is lost on process restart\n- File adapter: Check file write permissions\n- Redis: Verify connection and persistence settings                                                                                                                    |
| Concurrent Access | - Memory/File: Limited concurrent flow support\n- Redis: Use atomic operations and implement retry logic                                                                                                                                                                  |

-   [Api Step](/docs/concepts/steps/api.md): Documentation for Api Step.
---
title: Api Step
---

An API step is exposed as an HTTP endpoint that acts as an entry point into your sequence of steps, or **flow**. It allows external systems or clients to trigger and interact with your flows through a REST API interface. Like any Motia Step, an API Step can be configured to emit events or wait for events to occur.

## Config

The following properties are specific to the API Step, in addition to the [common step config](/docs/core/steps/defining-steps#config).

<DescriptionTable
  type={{
    path: {
      description: 'The development server api path to expose your api step handler',
      type: 'string',
    },
    method: {
      description: 'The HTTP method to use for the development server api endpoint',
      type: 'GET | POST',
    },
    bodySchema: {
      description:
        'In TS/JS we use zod to validate the request body, in Python/Ruby we use json schema to validate the request body.',
      type: 'JSON Schema',
    },
  }}
/>

The following examples showcase how to configure an **API Step**

<Tabs items={['TypeScript', 'JavaScript', 'Python', 'Ruby']}>
  <Tab value="TypeScript">
    ```typescript
      import { ApiRouteConfig, StepHandler } from '@motiadev/core'
      import { z } from 'zod'

      export const config: ApiRouteConfig = {
        type: 'api',
        name: 'Test state api trigger',
        description: 'test state',
        path: '/test-state',
        method: 'POST',
        emits: ['test-state'],
        bodySchema: z.object({}),
        flows: ['test-state'],
      }

      export const handler: StepHandler<typeof config> = async (req, { logger, emit }) => {
        logger.info('[Test State] Received request', req)

        await emit({
          topic: 'test-state',
          data: req.body
        })

        return {
          status: 200,
          body: { message: 'Success' },
        }
      }
    ```

  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const { z } = require('zod')

    exports.config = {
      type: 'api',
      name: 'Test state api trigger',
      description: 'test state',
      path: '/test-state',
      method: 'POST',
      emits: ['test-state'],
      bodySchema: z.object({}),
      flows: ['test-state'],
    }

    exports.handler = async (req, { logger, emit }) => {
      logger.info('[Test State] Received request', req)

      await emit({
        topic: 'test-state',
        data: req.body
      })

      return {
        status: 200,
        body: { message: 'Success' },
      }
    }
    ```

  </Tab>

  <Tab value="Python">
    ```python
    config = {
        'type': 'api',
        'name': 'Test state api trigger',
        'description': 'test state',
        'path': '/test-state',
        'method': 'POST',
        'emits': ['test-state'],
        'flows': ['test-state']
    }

    async def handler(req, context):
        context.logger.info('[Test State] Received request', {'body': req.body})

        await context.emit({
            'type': 'test-state',
            'data': req.body
        })

        return {
            'status': 200,
            'body': {'message': 'Success'}
        }
    ```

  </Tab>
  <Tab value="Ruby">
    ```ruby
    def config
      {
        type: 'api',
        name: 'Test state api trigger',
        description: 'test state',
        path: '/test-state',
        method: 'POST',
        emits: ['test-state'],
        flows: ['test-state']
      }
    end

    def handler(req, ctx)
      ctx.emit({
        "topic" => "test-state",
        "data" => req.body
      })

      {
        "status" => 200,
        "body" => { "message" => "Success" }
      }
    end
    ```

  </Tab>
</Tabs>


-   [Cron Step](/docs/concepts/steps/cron.md): Documentation for Cron Step.
---
title: Cron Step
---

The **Cron Step** allows you to schedule your steps to run at specified intervals. It is a powerful tool for automating your business logic.

## Config

The following properties are specific to the Cron Step, in addition to the [common step config](/docs/core/steps/defining-steps#config).

<DescriptionTable
  type={{
    cron: {
      description: 'The cron schedule expression for your step',
      type: 'string',
    },
  }}
/>

The following examples showcase how to configure an **CRON Step**

<Tabs  items={['TS', 'JS', 'Python', 'Ruby']}>
  <Tab value="TS">
    ```typescript
    import { CronConfig } from '@motiadev/core'

    export const config: CronConfig = {
      type: 'cron' as const,
      name: 'PeriodicJob',
      description: 'Runs every minute and emits a timestamp',
      cron: '0 * * * *', // run every hour at minute 0
      emits: ['cron-ticked'],
      flows: ['cron-example'],
    }

    export const handler: StepHandler<typeof config> = async ({ emit }) => {
      await emit({
        topic: 'cron-ticked',
        data: { message: 'Cron job executed' },
      })
    }
    ```

  </Tab>
  <Tab value="JS">
    ```javascript
    const config = {
      type: 'cron',
      name: 'PeriodicJob',
      description: 'Runs every minute and emits a timestamp',
      cron: '0 * * * *', // run every hour at minute 0
      emits: ['cron-ticked'],
      flows: ['cron-example'],
    };

    const handler = async ({ emit }) => {
      await emit({
        topic: 'cron-ticked',
        data: { message: 'Cron job executed' },
      })
    }

    ```

  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "type": "cron",
        "name": "PeriodicJob",
        "description": "Runs every minute and emits a timestamp",
        "cron": "0 * * * *",
        "emits": ["cron-ticked"],
        "flows": ["cron-example"]
    }
  
    async def handler(context):
        await context.emit({
            "topic": "cron-ticked",
            "data": { "message": "Cron job executed" },
        })

    ```

  </Tab>
  <Tab value="Ruby">
    ```ruby
    def config
      {
        type: 'cron',
        name: 'PeriodicJob',
        description: 'Runs every minute and emits a timestamp',
        cron: '0 * * * *',
        emits: ['cron-ticked'],
        flows: ['cron-example'],
      }
    end

    def handler(context)
      context.emit({
        topic: 'cron-ticked',
        data: { message: 'Cron job executed' },
      })
    end
    ```

  </Tab>
</Tabs>


-   [Defining Steps](/docs/concepts/steps/defining-steps.md): Documentation for Defining Steps.
---
title: Defining Steps
---

Steps are the fundamental building blocks in Motia that encapsulate isolated pieces of business logic. 

Steps have two core behaviors:

1. **Event Subscription**: Steps can subscribe to specific topics, allowing them to listen and react to particular events.
2. **Event Emission**: Steps can emit new topics, triggering an event for other steps to react to.

Steps can operate in two different patterns:
- **Independent**: Each step can function as a standalone unit, processing its logic in isolation.
- **Flow**: Steps can be connected together in a sequence, creating a **flow** where the output of one step becomes the input for another.

This modular approach allows you to:
- Build reusable components of business logic
- Create complex workflows by combining simple steps
- Maintain clear separation of concerns
- Scale and modify parts of your system independently

Steps can be defined in any language that Motia supports, such as TypeScript, JavaScript, Python, and Ruby. Steps can be of type [`event`](/docs/core/steps/event), [`api`](/docs/core/steps/api), or [`cron`](/docs/core/steps/cron). Steps are composed of a `config` object and a `handler` function.

## Config

A step's configuration is defined through a `config` object that must be exported. This object contains essential properties that tell Motia how to interact with the step.

<DescriptionTable
  type={{
    type: {
      description: 'The step type: event, api, or cron',
      type: 'string',
    },
    name: {
      description: 'A unique identifier for the step, used in Motia Workbench visualization tool',
      type: 'string',
    },
    subscribes: {
      description: 'A list of topics this step listens to',
      type: 'string[]',
      default: []
    },
    emits: {
      description: 'A list of topics this step can emit',
      type: 'string[]',
    },
    flows: {
      description: 'A list of flow identifiers that this step belongs to',
      type: 'string[]',
    },
    description: {
      description: 'Optional description for documentation and visualization',
      type: 'string',
    }
  }}
/>

Each step type has its own set of properties, specific to that step type, which are described in the following sections.

<Breadcrumb items={[{
  name: 'Event Steps',
  url: '/docs/concepts/steps/event'
}, {
  name: 'API Steps',
  url: '/docs/concepts/steps/api'
}, {
  name: 'Cron Steps',
  url: '/docs/concepts/steps/cron'
}]} />

## Handler

A handler holds the business logic of a step. When an event occurs that matches the step's subscribed topics, the handler automatically runs with two key pieces of information:

1. The input data from the triggering event
2. A context object that provides useful tools:
   - `emit`: Sends new events to other steps
   - `traceId`: Helps track the flow of operations
   - `state`: Manages data persistence
   - `logger`: Records important information

Here're examples of how to define a handler in the Motia supported languages:

<Tabs  items={['TS', 'JS', 'Python', 'Ruby']}>
  <Tab value='TS'>
    ```typescript
    import { FlowContext, StepHandler } from '@motiadev/core'

    // ... step config

    export const handler: StepHandler<typeof config> = async (input, { emit, traceId, state, logger }: FlowContext) => {
      // ... business logic here
      // ...emit new events to other steps
    }
    ```
  </Tab>
  <Tab value='JS'>
    ```javascript
    // ... step config

    const handler = async (input, { emit, traceId, state, logger }) => {
      // ... business logic here
      // ...emit new events to other steps
    }

    module.exports = {config, handler}
    ```
  </Tab>
  <Tab value='Python'>
    ```python
    async def handler(args, ctx):
        # ... business logic here
        # ...emit new events to other steps
    ```
  </Tab>
  <Tab value='Ruby'>
  ```ruby
    def handler(args, ctx)
        # ... business logic here
        # ...emit new events to other steps
    end
    ```
  </Tab>
</Tabs>

<Callout>
Follow the **[quick start](/docs/quick-start)** guide if you haven't set up Motia yet.
</Callout>


-   [Event Step](/docs/concepts/steps/event.md): Documentation for Event Step.
---
title: Event Step
---

The **Event Step** lets you define custom logic in response to subscribed events and at the same time trigger other steps by emitting new events. It enables communication between different parts of your flow.

## Config

The following properties are specific to the Event Step, in addition to the [common step config](/docs/core/steps/defining-steps#config).

<DescriptionTable
  type={{
    input: {
      description: 'This is only required for TS or JS steps that use zod for their input schema, this is used when processing the step to validate the input before executing the step handler.',
      type: 'string[]',
    },
  }}
/>

The following examples showcase how to configure an **Event Step**

<Tabs  items={['TS', 'JS', 'Python', 'Ruby']}>
  <Tab value="TS">
    ```typescript
    import { EventConfig, StepHandler } from '@motiadev/core'
    import { z } from 'zod'

    const inputSchema = z.object({
      message: z.string()
    })

    type Input = typeof inputSchema

    export const config: EventConfig<Input> = {
      type: 'event',
      name: 'stepA',
      description: 'Hello from Step A',
      subscribes: ['pms.start'],
      emits: ['pms.stepA.done'],
      input: inputSchema,
      flows: ['parallel-merge'],
    }

    export const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {
      logger.info('Processing message:', input.message)
      
      await emit({
        topic: 'pms.stepA.done',
        data: {
          result: `Processed: ${input.message}`
        }
      })
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    const z = require('zod');

    const inputSchema = z.object({
      message: z.string()
    });

    const config = {
      type: 'event',
      name: 'stepA',
      description: 'Hello from Step A',
      subscribes: ['pms.start'],
      emits: ['pms.stepA.done'],
      input: inputSchema,
      flows: ['parallel-merge'],
    };

    const handler = async (input, { emit, logger }) => {
      logger.info('Processing message:', input.message)
      
      await emit({
        topic: 'pms.stepA.done',
        data: {
          result: `Processed: ${input.message}`
        }
      })
    };

    module.exports = { config, handler };
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "type": "event",
        "name": "Call OpenAI",
        "subscribes": ["call-openai"], 
        "emits": ["openai-response"],
        "input": None,  # No schema validation in Python version
        "flows": ["openai"]
    }

    async def handler(input, context):
        context.logger.info('Processing input:', input)
        
        await context.emit({
            "topic": "openai-response",
            "data": {
                "result": f"Processed: {input.get('message', '')}"
            }
        })
    ```
  </Tab>
  <Tab value="Ruby">
    ```ruby
    class Config
      attr_reader :type, :name, :subscribes, :emits, :input, :flows

      def initialize
        @type = "event"
        @name = "Call OpenAI"
        @subscribes = ["call-openai"]
        @emits = ["openai-response"]
        @input = nil # No schema validation
        @flows = ["openai"]
      end
    end

    config = Config.new

    def handler(input, context)
      context.logger.info("Processing input: #{input}")
      
      context.emit({
        topic: "openai-response",
        data: {
          result: "Processed: #{input[:message]}"
        }
      })
    end
    ```
  </Tab>
</Tabs>

## Example




-   [testing](/docs/concepts/testing.md): Documentation for testing.
---
title: Testing
description: Learn how to write and run tests for your Motia components
---

# Testing

Testing is an essential part of building reliable and maintainable Motia applications. Motia provides built-in support for writing and running tests to ensure the correctness of your steps, flows, and event handling logic.

## Writing Tests for Motia Components

Motia uses [Jest](https://jestjs.io/) as its testing framework. You can write tests for your Motia components using Jest's syntax and assertions.

### Step Tests

To test a step, create a test file with the same name as the step file, but with a `.test.ts` or `.test.js` extension. For example, if your step file is named `my-step.step.ts`, create a test file named `my-step.step.test.ts`.

Here's an example of a step test:

```typescript
// my-step.step.test.ts
import { createTestContext } from '@motiadev/testing'
import { handler } from './my-step.step'

describe('MyStep', () => {
  it('should emit an event with the correct data', async () => {
    const { emit, done } = createTestContext()

    await handler({ name: 'John' }, { emit })

    expect(emit).toHaveBeenCalledWith({
      topic: 'my-event',
      data: { greeting: 'Hello, John!' },
    })

    done()
  })
})
```

In this example, we use the `createTestContext` function from `@motiadev/testing` to create a test context with mocked `emit` and `done` functions. We then call the step's `handler` function with test input and the mocked context. Finally, we assert that the `emit` function was called with the expected event type and data.

### Flow Tests

To test a flow, create a test file with the flow name and a `.test.ts` or `.test.js` extension. For example, if your flow is named `my-flow`, create a test file named `my-flow.test.ts`.

Here's an example of a flow test:

```typescript
// my-flow.test.ts
import { createTestFlow } from '@motiadev/testing'
import { handler as stepAHandler } from './step-a.step'
import { handler as stepBHandler } from './step-b.step'

describe('MyFlow', () => {
  it('should execute steps in the correct order', async () => {
    const flow = createTestFlow('my-flow')
      .step('step-a', stepAHandler)
      .step('step-b', stepBHandler)

    const result = await flow.execute({ name: 'Alice' })

    expect(result).toEqual({
      greeting: 'Hello, Alice!',
      message: 'Welcome to Motia!',
    })
  })
})
```

In this example, we use the `createTestFlow` function from `@motiadev/testing` to create a test flow with the specified steps. We then execute the flow with test input and assert that the final result matches the expected output.

## Running Tests Locally

To run tests locally, use the following command:

```bash
pnpm test
```

This command will run all the test files in your project and display the test results in the terminal.

You can also run tests in watch mode, which automatically re-runs the tests whenever you make changes to your code:

```bash
pnpm test --watch
```

## Best Practices

- Write tests for each step and flow to ensure comprehensive coverage.
- Use meaningful test case descriptions to clarify the purpose of each test.
- Test edge cases and error scenarios to ensure your components handle them gracefully.
- Keep your tests focused and independent to make them easier to maintain.
- Use mocks and stubs to isolate dependencies and improve test reliability.

By following these best practices and regularly running tests, you can catch bugs early, maintain code quality, and ensure the reliability of your Motia application. 

-   [how-to-contribute](/docs/contribution/how-to-contribute.md): Documentation for how-to-contribute.
---
title: How to Contribute
description: Guide for developers who want to contribute to Motia
---

# How to Contribute

Thank you for your interest in contributing to Motia! We welcome contributions from the community to help make Motia better. Here are some ways you can contribute:

## Reporting Issues

If you encounter any bugs, have feature requests, or want to discuss improvements, please [open an issue](https://github.com/MotiaDev/motia/issues) on our GitHub repository. When reporting bugs, please provide detailed information about your environment and steps to reproduce the issue.

## Submitting Pull Requests

We appreciate pull requests for bug fixes, enhancements, or new features. To submit a pull request:

1. Fork the [Motia repository](https://github.com/MotiaDev/motia) on GitHub.
2. Create a new branch from the `main` branch for your changes.
3. Make your modifications and ensure that the code follows our coding conventions.
4. Write tests to cover your changes, if applicable.
5. Commit your changes and push them to your forked repository.
6. Open a pull request against the `main` branch of the Motia repository.

Please provide a clear description of your changes in the pull request, along with any relevant information or context.

## Documentation Improvements

Improving the documentation is a great way to contribute to Motia. If you find any errors, typos, or areas that need clarification, please submit a pull request with the necessary changes. The documentation source files are located in the `packages/docs/content` directory.

## Sharing Examples and Use Cases

If you have built something interesting with Motia or have a real-world use case to share, we would love to showcase it in our [Examples](/docs/examples) section. You can contribute your examples by submitting a pull request to the [Motia Examples repository](https://github.com/MotiaDev/motia-examples).

## Spreading the Word

Help spread the word about Motia by sharing it with your friends, colleagues, and the developer community. You can also star our [GitHub repository](https://github.com/MotiaDev/motia), follow us on [Twitter](https://twitter.com/motiadev), and join our [Discord community](https://discord.gg/motia) to stay updated with the latest news and engage with other Motia developers.

We appreciate all forms of contributions and look forward to collaborating with you to make Motia even better! 

-   [Examples](/docs/examples/index.md): Documentation for Examples.
---
title: Examples
---

We have curated a few examples to help you get started with Motia.

<Cards>
  <Card
    title="Sentiment Analysis"
    href="/docs/examples/sentiment-analysis"
    description="Sometimes you don't just want a simple â€œprompt => response.â€ Instead, you want the LLM to decide how to proceed A real-world example of a sentiment analysis flow"
  />
</Cards>

<br/>

## Contribute

We welcome contributions to the examples. Please submit a PR to the [examples repository](https://github.com/motiadev/motia-examples).



## Examples
[Examples](/docs/examples/index.md): Code example
---
title: Examples
---

We have curated a few examples to help you get started with Motia.

<Cards>
  <Card
    title="Sentiment Analysis"
    href="/docs/examples/sentiment-analysis"
    description="Sometimes you don't just want a simple â€œprompt => response.â€ Instead, you want the LLM to decide how to proceed A real-world example of a sentiment analysis flow"
  />
</Cards>

<br/>

## Contribute

We welcome contributions to the examples. Please submit a PR to the [examples repository](https://github.com/motiadev/motia-examples).


-   [Dynamic Sentiment Analysis](/docs/examples/sentiment-analysis.md): Documentation for Dynamic Sentiment Analysis.
---
title: Dynamic Sentiment Analysis
---

Sometimes you don't just want a **simple** "prompt => response." Instead, you want the LLM to decide how to proceed. Below is a minimal example that:

1. Receives user input via `POST /api/analyze-sentiment`
2. Calls OpenAI and **instructs** the LLM to return JSON with a `sentiment` field
3. Parses that JSON and **emits** different events depending on whether `sentiment` is `"positive"` or `"negative"` (or anything else)
4. Two specialized responders handle each sentiment separately

---

## The Steps

<Folder name="steps" defaultOpen>
  <File name="analyzeSentimentApi.step.ts" />
  <File name="openAiAnalyzeSentiment.step.ts" />
  <File name="handlePositive.step.ts" />
  <File name="handleNegative.step.ts" />
</Folder>


<Tabs items={['analyzeSentimentApi', 'openAiAnalyzeSentiment', 'handlePositive', 'handleNegative']}>
  <Tab value="analyzeSentimentApi">
    ```ts
    // Receives user text, emits "openai.analyzeSentimentRequest".
    import { ApiRouteConfig, StepHandler } from 'wistro'
    import { z } from 'zod'

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'Analyze Sentiment (API)',
      path: '/api/analyze-sentiment',
      method: 'POST',
      emits: ['openai.analyzeSentimentRequest'],
      bodySchema: z.object({
        text: z.string().min(1, 'text is required'),
      }),
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (req, { emit, logger }) => {
      const { text } = req.body

      logger.info('[AnalyzeSentimentAPI] Received text', { text })

      // Emit an event to call OpenAI
      await emit({
        topic: 'openai.analyzeSentimentRequest',
        data: { text },
      })

      // Return right away
      return {
        status: 200,
        body: { status: 'Accepted', message: 'Your text is being analyzed' },
      }
    }
    ```
  </Tab>
  <Tab value="openAiAnalyzeSentiment">
    ```ts
    // Calls OpenAI, instructing it to ONLY return JSON like {"sentiment":"positive","analysis":"..."}
    import { EventConfig, StepHandler } from 'wistro'
    import { z } from 'zod'
    import { OpenAI } from 'openai'

    // 1) Create an OpenAI client (newer syntax)
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })

    // 2) Define the input schema for your step
    const inputSchema = z.object({
      text: z.string(),
    })

    export const config: EventConfig<typeof inputSchema> = {
      type: 'event',
      name: 'OpenAI Sentiment Analyzer',
      subscribes: ['openai.analyzeSentimentRequest'],
      // We'll emit different events: "openai.positiveSentiment" or "openai.negativeSentiment"
      emits: ['openai.positiveSentiment', 'openai.negativeSentiment'],
      input: inputSchema,
      flows: ['sentiment-demo'],
    }

    // 3) Provide the code that runs on each event
    export const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {
      logger.info('[OpenAI Sentiment Analyzer] Prompting OpenAI...', { text: input.text })

      try {
        // We'll ask the model to ONLY return JSON with a "sentiment" field
        const systemPrompt =
          'You are an assistant that returns only JSON: {"sentiment":"positive|negative","analysis":"..."}'
        const userPrompt = `Analyze the sentiment of this text: "${input.text}". Return JSON with keys "sentiment" and "analysis".`

        // 4) Use the new openai syntax:
        const response = await openai.chat.completions.create({
          model: 'gpt-3.5-turbo',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt },
          ],
        })

        // 5) Log and parse the response
        const content = response.choices[0]?.message?.content || ''
        logger.info('[OpenAI Sentiment Analyzer] Raw response', { content })

        let parsed: { sentiment?: string; analysis?: string } = {}
        try {
          parsed = JSON.parse(content.trim())
        } catch (err) {
          logger.error('[OpenAI Sentiment Analyzer] Unable to parse JSON', { error: err })
          // If it's not JSON, we bail or handle differently
          return
        }

        // 6) Decide how to route the event
        if (parsed.sentiment?.toLowerCase() === 'positive') {
          await emit({
            topic: 'openai.positiveSentiment',
            data: { ...parsed },
          })
        } else {
          // default to negative
          await emit({
            topic: 'openai.negativeSentiment',
            data: { ...parsed },
          })
        }
      } catch (err: any) {
        logger.error('[OpenAI Sentiment Analyzer] Error calling OpenAI', { error: err.message })
      }
    }
    ```
  </Tab>
  <Tab value="handlePositive">
    ```ts
    // Handles "openai.positiveSentiment"
    import { EventConfig, StepHandler } from 'wistro'
    import { z } from 'zod'

    const positiveSchema = z.object({
      sentiment: z.string(),
      analysis: z.string().optional(),
    })

    export const config: EventConfig<typeof positiveSchema> = {
      type: 'event',
      name: 'Positive Sentiment Responder',
      subscribes: ['openai.positiveSentiment'],
      emits: [],
      input: positiveSchema,
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (input, { logger }) => {
      logger.info('[Positive Responder] The sentiment is positive!', { analysis: input.analysis })
      // Maybe notify a Slack channel: "All good vibes here!"
    }
    ```
  </Tab>
  <Tab value="handleNegative">
    ```ts
    // Handles "openai.negativeSentiment"
    import { EventConfig, StepHandler } from 'wistro'
    import { z } from 'zod'

    const negativeSchema = z.object({
      sentiment: z.string(),
      analysis: z.string().optional(),
    })

    export const config: EventConfig<typeof negativeSchema> = {
      type: 'event',
      name: 'Negative Sentiment Responder',
      subscribes: ['openai.negativeSentiment'],
      emits: [],
      input: negativeSchema,
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (input, { logger }) => {
      logger.info('[Negative Responder] The sentiment is negative or unknown.', { analysis: input.analysis })
      // Could escalate to a service, or respond gently, etc.
    }
    ```
  </Tab>
</Tabs>

---

## Visual Overview

Here's how the events chain together:

<div className="my-8">
  ![Flow: Sentiment Analysis Steps](./../img/sentiment-analyzer.png)
</div>

1. **Analyze Sentiment (API)** â†’ emits `openai.analyzeSentimentRequest`
2. **OpenAI Sentiment Analyzer** â†’ calls OpenAI, parses JSON â†’
   - If `sentiment: "positive"` â†’ emits `openai.positiveSentiment`
   - Else â†’ emits `openai.negativeSentiment`
3. **Positive Sentiment Responder** or **Negative Sentiment Responder**

---

## Trying It Out

<Steps>

### Install Dependencies

```shell
pnpm install wistro openai
```

### Create Project Structure

<Folder name="steps" defaultOpen>
  <File name="analyzeSentimentApi.step.ts" />
  <File name="openAiAnalyzeSentiment.step.ts" />
  <File name="handlePositive.step.ts" />
  <File name="handleNegative.step.ts" />
</Folder>

### Set Environment Variables

```shell
export OPENAI_API_KEY="sk-..."
```

### Run the Project

```shell
pnpm wistro dev
```

### Test the API

```shell
curl -X POST http://localhost:3000/api/analyze-sentiment \
  -H "Content-Type: application/json" \
  -d '{"text":"I absolutely love this new device!"}'
```

Check your logs - you should see either the `[Positive Responder]` or `[Negative Responder]` step firing, depending on the LLM's JSON output.

### Extend Further

Here are some ways to build upon this example:
- Tweak the system instructions to force certain outputs or include more details
- Create more specialized responders (like "neutralSentiment")
- Integrate a notification step (Slack, database, etc.)

</Steps>

Try it out, see the branching logic in action, and enjoy skipping all the boring boilerplate!



## Examples
[Dynamic Sentiment Analysis](/docs/examples/sentiment-analysis.md): Code example
---
title: Dynamic Sentiment Analysis
---

Sometimes you don't just want a **simple** "prompt => response." Instead, you want the LLM to decide how to proceed. Below is a minimal example that:

1. Receives user input via `POST /api/analyze-sentiment`
2. Calls OpenAI and **instructs** the LLM to return JSON with a `sentiment` field
3. Parses that JSON and **emits** different events depending on whether `sentiment` is `"positive"` or `"negative"` (or anything else)
4. Two specialized responders handle each sentiment separately

---

## The Steps

<Folder name="steps" defaultOpen>
  <File name="analyzeSentimentApi.step.ts" />
  <File name="openAiAnalyzeSentiment.step.ts" />
  <File name="handlePositive.step.ts" />
  <File name="handleNegative.step.ts" />
</Folder>


<Tabs items={['analyzeSentimentApi', 'openAiAnalyzeSentiment', 'handlePositive', 'handleNegative']}>
  <Tab value="analyzeSentimentApi">
    ```ts
    // Receives user text, emits "openai.analyzeSentimentRequest".
    import { ApiRouteConfig, StepHandler } from 'wistro'
    import { z } from 'zod'

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'Analyze Sentiment (API)',
      path: '/api/analyze-sentiment',
      method: 'POST',
      emits: ['openai.analyzeSentimentRequest'],
      bodySchema: z.object({
        text: z.string().min(1, 'text is required'),
      }),
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (req, { emit, logger }) => {
      const { text } = req.body

      logger.info('[AnalyzeSentimentAPI] Received text', { text })

      // Emit an event to call OpenAI
      await emit({
        topic: 'openai.analyzeSentimentRequest',
        data: { text },
      })

      // Return right away
      return {
        status: 200,
        body: { status: 'Accepted', message: 'Your text is being analyzed' },
      }
    }
    ```
  </Tab>
  <Tab value="openAiAnalyzeSentiment">
    ```ts
    // Calls OpenAI, instructing it to ONLY return JSON like {"sentiment":"positive","analysis":"..."}
    import { EventConfig, StepHandler } from 'wistro'
    import { z } from 'zod'
    import { OpenAI } from 'openai'

    // 1) Create an OpenAI client (newer syntax)
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })

    // 2) Define the input schema for your step
    const inputSchema = z.object({
      text: z.string(),
    })

    export const config: EventConfig<typeof inputSchema> = {
      type: 'event',
      name: 'OpenAI Sentiment Analyzer',
      subscribes: ['openai.analyzeSentimentRequest'],
      // We'll emit different events: "openai.positiveSentiment" or "openai.negativeSentiment"
      emits: ['openai.positiveSentiment', 'openai.negativeSentiment'],
      input: inputSchema,
      flows: ['sentiment-demo'],
    }

    // 3) Provide the code that runs on each event
    export const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {
      logger.info('[OpenAI Sentiment Analyzer] Prompting OpenAI...', { text: input.text })

      try {
        // We'll ask the model to ONLY return JSON with a "sentiment" field
        const systemPrompt =
          'You are an assistant that returns only JSON: {"sentiment":"positive|negative","analysis":"..."}'
        const userPrompt = `Analyze the sentiment of this text: "${input.text}". Return JSON with keys "sentiment" and "analysis".`

        // 4) Use the new openai syntax:
        const response = await openai.chat.completions.create({
          model: 'gpt-3.5-turbo',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt },
          ],
        })

        // 5) Log and parse the response
        const content = response.choices[0]?.message?.content || ''
        logger.info('[OpenAI Sentiment Analyzer] Raw response', { content })

        let parsed: { sentiment?: string; analysis?: string } = {}
        try {
          parsed = JSON.parse(content.trim())
        } catch (err) {
          logger.error('[OpenAI Sentiment Analyzer] Unable to parse JSON', { error: err })
          // If it's not JSON, we bail or handle differently
          return
        }

        // 6) Decide how to route the event
        if (parsed.sentiment?.toLowerCase() === 'positive') {
          await emit({
            topic: 'openai.positiveSentiment',
            data: { ...parsed },
          })
        } else {
          // default to negative
          await emit({
            topic: 'openai.negativeSentiment',
            data: { ...parsed },
          })
        }
      } catch (err: any) {
        logger.error('[OpenAI Sentiment Analyzer] Error calling OpenAI', { error: err.message })
      }
    }
    ```
  </Tab>
  <Tab value="handlePositive">
    ```ts
    // Handles "openai.positiveSentiment"
    import { EventConfig, StepHandler } from 'wistro'
    import { z } from 'zod'

    const positiveSchema = z.object({
      sentiment: z.string(),
      analysis: z.string().optional(),
    })

    export const config: EventConfig<typeof positiveSchema> = {
      type: 'event',
      name: 'Positive Sentiment Responder',
      subscribes: ['openai.positiveSentiment'],
      emits: [],
      input: positiveSchema,
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (input, { logger }) => {
      logger.info('[Positive Responder] The sentiment is positive!', { analysis: input.analysis })
      // Maybe notify a Slack channel: "All good vibes here!"
    }
    ```
  </Tab>
  <Tab value="handleNegative">
    ```ts
    // Handles "openai.negativeSentiment"
    import { EventConfig, StepHandler } from 'wistro'
    import { z } from 'zod'

    const negativeSchema = z.object({
      sentiment: z.string(),
      analysis: z.string().optional(),
    })

    export const config: EventConfig<typeof negativeSchema> = {
      type: 'event',
      name: 'Negative Sentiment Responder',
      subscribes: ['openai.negativeSentiment'],
      emits: [],
      input: negativeSchema,
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (input, { logger }) => {
      logger.info('[Negative Responder] The sentiment is negative or unknown.', { analysis: input.analysis })
      // Could escalate to a service, or respond gently, etc.
    }
    ```
  </Tab>
</Tabs>

---

## Visual Overview

Here's how the events chain together:

<div className="my-8">
  ![Flow: Sentiment Analysis Steps](./../img/sentiment-analyzer.png)
</div>

1. **Analyze Sentiment (API)** â†’ emits `openai.analyzeSentimentRequest`
2. **OpenAI Sentiment Analyzer** â†’ calls OpenAI, parses JSON â†’
   - If `sentiment: "positive"` â†’ emits `openai.positiveSentiment`
   - Else â†’ emits `openai.negativeSentiment`
3. **Positive Sentiment Responder** or **Negative Sentiment Responder**

---

## Trying It Out

<Steps>

### Install Dependencies

```shell
pnpm install wistro openai
```

### Create Project Structure

<Folder name="steps" defaultOpen>
  <File name="analyzeSentimentApi.step.ts" />
  <File name="openAiAnalyzeSentiment.step.ts" />
  <File name="handlePositive.step.ts" />
  <File name="handleNegative.step.ts" />
</Folder>

### Set Environment Variables

```shell
export OPENAI_API_KEY="sk-..."
```

### Run the Project

```shell
pnpm wistro dev
```

### Test the API

```shell
curl -X POST http://localhost:3000/api/analyze-sentiment \
  -H "Content-Type: application/json" \
  -d '{"text":"I absolutely love this new device!"}'
```

Check your logs - you should see either the `[Positive Responder]` or `[Negative Responder]` step firing, depending on the LLM's JSON output.

### Extend Further

Here are some ways to build upon this example:
- Tweak the system instructions to force certain outputs or include more details
- Create more specialized responders (like "neutralSentiment")
- Integrate a notification step (Slack, database, etc.)

</Steps>

Try it out, see the branching logic in action, and enjoy skipping all the boring boilerplate!


-   [core-concepts](/docs/getting-started/core-concepts.md): Documentation for core-concepts.
---
title: Core Concepts
description: Understand the fundamental concepts behind Motia - Steps, Flows, Events, and Topics.
---

# Core Concepts: Building Blocks of Motia

To effectively build and utilize Motia, it's essential to grasp its foundational concepts. Motia workflows are built upon four key building blocks that work together to create powerful and flexible automation solutions: **Steps**, **Flows**, **Events**, and **Topics**.

This section provides a high-level overview of each concept. For a more in-depth understanding, follow the "Learn More" links provided for each section.

## The Four Pillars of Motia Workflows

At its heart, Motia is designed around an event-driven architecture, allowing you to compose complex workflows from simple, independent units.  These core concepts are the foundation:

| Concept     | Description                                                                                                                                | Key Function                                                                                                                               |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Steps**   | Self-contained, reusable units of business logic. Steps are the workhorses of Motia, performing specific tasks within a workflow.         | Process data, interact with external systems, perform computations, manage state, and emit events to trigger subsequent actions.        |
| **Flows**   | Logical containers that group related Steps together. Flows define the context and scope for a specific automation process.                | Organize and visualize workflows, provide a namespace for events, and enable flow-specific logging and state management.                 |
| **Events**  | Lightweight messages that carry data and signal occurrences within the system. Events are the communication mechanism between Steps.      | Trigger Step execution, carry data between Steps, enable asynchronous and loosely coupled interactions.                               |
| **Topics**  | Named channels or categories to which Events are published and Steps subscribe. Topics enable event routing and decouple Steps from each other. | Define event types, enable Steps to listen for specific events, and allow for flexible and dynamic workflow orchestration.        |

## ðŸ§± Steps: The Units of Logic

**Steps** are the fundamental building blocks in Motia. They are self-contained units of code that perform a specific action or task within your workflow.  Think of them as individual functions or micro-services within your automation.

**Key Characteristics of Steps:**

*   **Encapsulated Logic:** Each Step encapsulates a distinct piece of business logic, making your workflows modular and maintainable.  Steps are designed to be self-contained units, promoting code organization and reusability.
*   **Handler Function:**  At the heart of every Step is a simple `handler` function. This function is where you write the core logic of your step, defining how it processes events, interacts with external services, manages state, and emits new events.
*   **Leverage External Code:** Steps are not isolated silos! Within your `handler` function, you can import any necessary code â€“ whether it's from local files within your project or external packages installed via package managers like npm, pip, or RubyGems. This allows you to leverage existing libraries and tools to enhance your step's functionality.
*   **Reusability:** Steps are designed to be reusable across different flows and scenarios. Once you've created a Step, you can easily incorporate it into multiple workflows, saving development time and ensuring consistency.
*   **Event-Driven:** Steps react to specific events (through subscriptions) and trigger further actions by emitting new events. This event-driven nature enables asynchronous, loosely coupled, and highly responsive workflows.
*   **Multi-Language Support:** You can write Steps in TypeScript/JavaScript, Python, or Ruby, choosing the best language for the task at hand and even combining languages within the same workflow.
*   **Configurable:** Each Step has a configuration (`config` object) that must be exported. This object defines its type, name, event subscriptions, emissions, and other relevant properties, allowing you to customize the Step's behavior and metadata.

**Example Step Types:**

*   **API Step:** Exposes an HTTP endpoint to trigger a flow from external systems.
*   **Event Step:** Executes logic in response to a specific event within the Motia system.
*   **Cron Step:** Schedules tasks to run at specific intervals based on cron expressions.
*   **Noop Step:** Represents a placeholder for external processes or manual tasks, useful for visualization and workflow modeling.

**âž¡ï¸ [Learn More about Defining Steps](/docs/concepts/steps/defining-steps)**

## ðŸŒŠ Flows: Orchestrating Your Workflows

**Flows** provide a logical structure for organizing and managing your Steps.  A Flow represents a complete automation process, grouping together the Steps that work together to achieve a specific goal.

**Key Aspects of Flows:**

*   **Organization:** Flows help you structure complex automations by grouping related Steps, making your workflows easier to understand and manage.
*   **Visualization:** Motia Workbench uses Flows to visually represent your workflows as interactive diagrams, showing the connections and event flow between Steps.
*   **Context and Scope:** Flows define a context for Steps, allowing for flow-specific configurations, logging, and state management.
*   **Event Namespacing:** Events are often scoped within a Flow, ensuring that events emitted in one flow are less likely to interfere with events in another.

**Example Flow Scenarios:**

*   **Order Processing Flow:** Steps for order validation, payment processing, inventory updates, and shipping notifications.
*   **User Onboarding Flow:** Steps for account creation, email verification, welcome messages, and initial setup tasks.
*   **Data Synchronization Flow:** Steps for fetching data from an external source, transforming it, and updating a database.

**âž¡ï¸ [Learn More about Flows and Visualization](/docs/concepts/flows-and-visualization)**

## âœ‰ï¸ Events: The Language of Motia

**Events** are the lifeblood of Motia workflows. They are lightweight messages that are emitted by Steps to signal that something has happened or that a certain stage in a process has been reached.  Other Steps can then react to these events, creating a dynamic and responsive system.

**Key Characteristics of Events:**

*   **Asynchronous Communication:** Events enable Steps to communicate asynchronously and in a loosely coupled manner. Steps don't need to know about each other directly; they communicate through events.
*   **Data Carriers:** Events can carry data payloads, allowing Steps to pass information to each other as the workflow progresses.
*   **Typed Events:** Events have a `type` (or topic), which is a string identifier that indicates the kind of event that has occurred (e.g., `"order.created"`, `"payment.processed"`, `"data.transformed"`).
*   **Emission and Subscription:** Steps `emit` events to signal actions and `subscribe` to events to react to actions triggered by other Steps.

**Example Event Types:**

*   `order.created`:  Signals that a new order has been placed.
*   `payment.processed`: Indicates that a payment has been successfully processed.
*   `data.transformed`:  Signals that data transformation step has completed.
*   `email.sent`:  Indicates that an email notification has been sent.

TODO:
**âž¡ï¸ [Learn More about Event-Driven Architecture (external resource - consider linking to a good article on event-driven systems)]**

## ðŸ·ï¸ Topics: Routing and Filtering Events

**Topics** are used to categorize and route events within Motia.  When a Step emits an event, it emits it with a specific topic. Steps that are interested in handling that type of event `subscribe` to that topic.

**Key Roles of Topics:**

*   **Event Routing:** Topics act as channels, ensuring that events are delivered only to Steps that have subscribed to the relevant topic.
*   **Decoupling:** Topics further decouple Steps, as Steps only need to know about event topics, not about the specific Steps that might emit or handle those events.
*   **Flexibility and Scalability:** Topics enable flexible and scalable workflow designs. You can easily add new Steps that subscribe to existing topics or introduce new topics to extend your workflows.

**Example Topic Usage:**

*   A Step emitting an order confirmation event might use the topic `"order.confirmed"`.
*   Steps that need to handle order confirmations (e.g., sending email notifications, updating inventory) would subscribe to the `"order.confirmed"` topic.

TODO:
**âž¡ï¸ [Learn More about Topics and Event Routing (link to internal docs section on event manager or routing if you create one, otherwise, leave as external resource link to pub/sub patterns)]**

---

By understanding these four core concepts â€“ Steps, Flows, Events, and Topics â€“ you'll have a solid foundation for building powerful and maintainable automation workflows with Motia. Continue exploring the documentation to delve deeper into each concept and start building your own amazing automations!

-   [index](/docs/getting-started/index.md): Documentation for index.
---
title: Getting Started
description: Get started with Motia - A powerful automation framework
---

# Your Path to Intelligent Workflow Automation

Welcome to Motia!  Ready to build your first event-driven workflow? This guide will take you through the initial steps to get your Motia development environment set up and start building!

## In This Getting Started Guide, You'll Discover:

- **Effortless Installation:** Learn how to quickly install Motia and set up your development environment with minimal hassle.
- **Core Concepts Demystified:**  Understand the fundamental building blocks of Motia â€“ Steps, Flows, Events, and Topics â€“ in a clear and accessible way.
- **Your First Automation Flow - Step-by-Step:**  Build a simple yet functional automation workflow from scratch, getting hands-on experience with Motia's core features.
- **Environment Configuration Made Easy:**  Master the essential configurations to tailor Motia to your development needs and preferences.

## Prerequisites

Before you begin, ensure you have the following installed:

- **Node.js (v16.0 or later):** Motia runs on Node.js, so this is essential for running the development server and your workflows.
- **Basic Understanding of programming:**  motia steps are written in Javascript, Typescript, Python and/or Ruby.
- **Basic Understanding of React:**  While you don't need to be a React expert, a basic familiarity will be helpful for understanding the UI Workbench and customizing UI steps.

## Your Next Steps:

1.  **Installation:** [Get Motia Installed](/docs/getting-started/installation) -  Learn how to quickly install the core Motia framework and necessary dependencies in your project.
2.  **Quick Start Guide:** [Build Your First Flow](/docs/getting-started/quick-start) -  Follow our step-by-step guide to create a minimal Motia workflow and see it in action.
3.  **Core Concepts:** [Understand the Fundamentals](/docs/getting-started/core-concepts) -  Dive deeper into the essential concepts of Motia: Steps, Flows, Events, and Topics.

-   [Quick Start](/docs/getting-started/quick-start.md): Documentation for Quick Start.
---
title: Quick Start
---

This guide will walk you through everything you need to define a minimal **step**, set up your Motia project, and run the **Motia** dev server â€“ all in one go, using **pnpm** for package management.

<Steps>
  <Step>
  ### Setup your project: Create a New Project Folder

  Let's create a new Motia project in a dedicated folder. This is the recommended approach for keeping your projects organized.

  <Tabs items={['Automated', 'Manual']}>
<Tab value="Automated">
  <Tabs items={['npx', 'motia Global CLI']}>
    <Tab value="npx">
      Use `npx` to run the project creation command directly:

      <Tabs items={['npx']}>
        <Tab value="npx">
          ```bash
          npx motia create -t default -n <your-project-name>
          ```
        </Tab>
      </Tabs>
    </Tab>

    <Tab value="motia Global CLI">
      **First, install the Motia CLI globally:**

      <Tabs items={['pnpm (Global)', 'npm (Global)', 'yarn (Global)', 'bun (Global)']}>
        <Tab value="pnpm (Global)">
          ```bash
          npm install -g motia
          ```
        </Tab>
        <Tab value="npm (Global)">
          ```bash
          npm install -g motia
          ```
        </Tab>
        <Tab value="yarn (Global)">
          ```bash
          yarn global add motia
          ```
        </Tab>
        <Tab value="bun (Global)">
          ```bash
          bun add -g motia
          ```
        </Tab>
      </Tabs>

      **Then, create your project using the globally installed `motia` command:**

      ```bash
      motia create -t default -n <your-project-name>
      ```
    </Tab>
  </Tabs>

    *   **This will**:
        *   Download and run the Motia CLI project creation tool
        *   Create a new project directory named `<your-project-name>`.
        *   Set up a basic Motia project structure inside the new folder.
        *   Install necessary dependencies using pnpm within the project folder.
        *   Add a `dev` script to your `package.json`.
        *   Include example steps to get you started.

  <Callout type="info">
    **Choosing a Project Name:** Replace `<your-project-name>` with your desired project folder name.

    **Alternative Templates:** To see other templates, run: `npx motia templates` (or `motia templates` if you installed globally).
  </Callout>

  You should see a new folder created with the following files inside:

  <Files>
    <Folder name="steps" defaultOpen>
      <File name="one.step.ts" />
      <File name="two.step.ts" />
      <File name="api.step.ts" />
    </Folder>
    <File name="package.json" />
  </Files>
</Tab>
    <Tab value="Manual">
      <Callout>For these instructions we recommend using `pnpm`. For detailed installation instructions and package manager options, please refer to the [Installation Guide](/docs/getting-started/installation) (Note: In this Quick Start, automated project creation is highly recommended).</Callout>

      **Quick Setup Summary (Manual - Advanced Users):**

      1.  **Create a project directory:**
          ```bash
          mkdir <your-project-name> && cd <your-project-name>
          ```

      2.  **Initialize `package.json`:**
          ```bash
          npm init -y
          ```

      3.  **Install Core Packages:**
          ```package-install
          @motiadev/core @motiadev/workbench zod
          ```

      4.  **Add `dev` Script to `package.json`:**
          ```json
          {
            "scripts": {
              "dev": "motia dev"
            }
          }
          ```

      5.  **Optional TypeScript Setup:**
          ```package-install
          ts-node typescript -D
          ```

      6.  **Create `steps` Folder:**
          ```bash
          mkdir steps
          ```
    </Tab>
  </Tabs>

  </Step>
  <Step>
  ### Minimal Step Example (Already Included!)

  âœ¨ **Good News!** If you used the automated project setup with the `default` template (as recommended above), you can **skip this step!**

  The `default` template already includes example steps in the `steps` folder, including `addNumbers.step.js` (or similar, depending on the template). These pre-built steps are ready for you to explore and run.

  ---

  **If you chose not to use the template or want to create a step from scratch manually,** follow these steps:

  1.  **Create a `steps` folder** in your project's root directory (if you haven't already).

  2.  **Create a new file** named `addNumbers.step.js` (or `addNumbers.step.ts` for TypeScript) inside the `steps` folder.

      <Files>
        <Folder name="steps" defaultOpen>
          <File name="addNumbers.step.js" />
        </Folder>
      </Files>

  3.  **Paste the following code** into your `addNumbers.step.js` file:

      ```javascript
      exports.config = {
        type: 'event', // "event", "api", or "cron"
        name: 'AddNumbers',
        subscribes: ['add-numbers'],
        emits: ['numbers-added'],
        flows: ['numbers']
      }

      exports.handler = async (input, { emit }) => {
        const sum = (input.a || 0) + (input.b || 0)
        await emit({
          topic: 'numbers-added',
          data: { result: sum },
        })
      }
      ```

      This minimal step **listens** for the event `"add-numbers"` and **emits** `"numbers-added"`. It's a basic example to get you started.

  </Step>
  <Step>
  ### Start Motia Development Server & Workbench

  Now, let's start Motia and see your workflow in action!

  1.  **Open your terminal** in your Motia project's root directory (where your `package.json` file is located).

  2.  **Run the development server command:** Use the `dev` script that was set up in your `package.json`:

      <Tabs items={['pnpm', 'yarn', 'npm', 'bun']}>
        <Tab value='pnpm'>
          ```bash
          pnpm run dev
          ```
        </Tab>
        <Tab value='yarn'>
          ```bash
          yarn run dev
          ```
        </Tab>
        <Tab value='npm'>
          ```bash
          npm run dev
          ```
        </Tab>
        <Tab value='bun'>
          ```bash
          bun run dev
          ```
        </Tab>
      </Tabs>

      Motia will:

      *   **Scan** your `steps` folder for step definition files (`.step.ts`, `.step.js`, `.step.py`, `.step.rb`).
      *   **Register** your Steps with the Motia runtime.
      *   **Launch** a development server and the Motia Workbench UI (typically at [`http://localhost:3000`](http://localhost:3000)).

      <Callout type="info">
          **Changing the Port:** To run the Workbench on a different port, use the `--port` option:  `pnpm run dev --port 3001`
      </Callout>

  </Step>
  <Step>
    ### View your Flow in the Workbench

    1.  **Open your browser** and navigate to the Motia Workbench.  By default, it's running at:  [`http://localhost:3000`](http://localhost:3000) or [`http://127.0.0.1:3000`](http://127.0.0.1:3000).

    2.  **Locate your Flow in the Sidebar:** On the left sidebar of the Workbench UI, you should see a list of Flows.

        *   **For the default template:**  You'll find a flow named "**default**".
        *   **For the `addNumbers.step.js` example:** You'll find a flow named "**numbers**".

    3.  **Select your Flow:** Click on the flow name in the sidebar.

    4.  **Observe the Visual Flow:** You should now see a visual representation of your flow in the main panel. This is the Motia Workbench visualizing the steps and event flow within your application!

        TODO:
        ![Example Flow Visualization in Workbench - Placeholder Image Needed Here]

        <Callout type="info">
            You can click and drag the nodes in the visual editor to rearrange them for better clarity. Explore the UI to familiarize yourself with the Workbench!
        </Callout>

    </Step>
    <Step>
    ### Test your step

    You can test your step using the **Motia** CLI:

    <Tabs items={['cli', 'curl']}>
      <Tab value='cli'>
      If you used the automated project setup with the default template, you can test your step by emitting the following event:
      ```bash
      npx motia emit --topic test-state --message '{}'
      ```

      If you used the add number example, you can test your step by emitting the following event:

      ```bash
      npx motia emit --topic add-numbers --message '{"a": 5, "b": 3}'
      ```

      </Tab>
      <Tab value='curl'>
        If you used the automated project setup with the default template, you can test your step by emitting the following event:
        ```bash
        curl -X POST http://localhost:3001/default \
        -H "Content-Type: application/json" \
        -d '{}'
        ```
        <Callout type="warn">You can't test the add number example using curl, you will need to use the CLI, using an api endpoint requires an api step.</Callout>
      </Tab>
    </Tabs>

    Motia will:

    Emit a new event with the provided topic and message

    The event manager will detect the new event and match it against your registered step

    Execute your step with the provided input

    Log the journey of the event, including the emitted numbers-added event

    </Step>
</Steps>

-   [index](/docs/index.md): Documentation for index.
---
title: Welcome to Motia
description: Get started with Motia, a powerful framework for building event-driven workflows
---

# Code-First Framework for Intelligent Workflows

Motia is a **code-first framework** designed to empower developers to build robust, scalable, and observable event-driven workflows with unparalleled ease. We handle the infrastructure complexities, so you can focus on your business logic.

## Why Choose Motia?

Motia is built with the developer in mind, offering a unique blend of simplicity and power. Here's why Motia stands out:

- ðŸš€ **Zero Infrastructure Setup:** Say goodbye to the complexities of message queues and event brokers! Motia handles the underlying infrastructure, allowing you to focus solely on building your workflows.

- ðŸ”Œ **Plug-and-Play Steps in Your Language:**  Develop your workflow logic using the languages you love: JavaScript, TypeScript, Python, and Ruby. Mix and match languages within the same flow for ultimate flexibility.

- ðŸ“Š **Built-in Observability:** Gain deep insights into your workflows with real-time logs, traces, and interactive flow visualizations right in the Motia Workbench. Debugging and monitoring have never been easier.

- âš¡ **Out-of-the-Box API & Scheduling:**  Instantly expose your workflows as HTTP endpoints and schedule tasks with cron expressions â€“ no extra configuration needed.

- âœ¨ **Flexible and Extensible Architecture:**  Motia is designed to be easily extended and customized. Create custom steps, UI components, and adapt the framework to your specific needs.

- ðŸ§‘â€ðŸ’» **Developer-First Experience:**  From intuitive APIs and a powerful CLI to comprehensive documentation and a visual workbench, Motia prioritizes developer productivity and a smooth, enjoyable development experience.

## Motia Workbench: Your Development Control Center

Motia Workbench is a built-in, browser-based development platform that acts as your central hub for building, testing, and debugging Motia flows. Key features include:

- **Interactive Flow Visualization:**  See your workflows come to life as dynamic diagrams, making it easy to understand complex event flows and step interactions.

- **Real-time Flow Testing:**  Trigger API endpoints and monitor event propagation through your steps, all within the Workbench UI. Inspect data at each stage to ensure your flows are behaving as expected.

- **Live Log Streaming:**  Access detailed, real-time logs directly in the Workbench. Filter and search logs to quickly pinpoint issues and monitor workflow execution.

- **Step-Level Customization:**  Create custom UI components for your steps to enhance visualization and provide context-specific information directly within the flow diagram.

<div className="my-8">
  ![Motia Workbench Interface](./img/workbench-presentation.png)
</div>

## Core Concepts: Building Blocks of Motia

Motia workflows are built using a few core concepts that work together harmoniously:

| Concept    | Description                                                                                                |
| ---------- | ---------------------------------------------------------------------------------------------------------- |
| **Steps**  | Self-contained, reusable units of business logic. Steps subscribe to events, process data, and emit events. |
| **Flows**  | Logical groupings of related steps that together accomplish a specific task or process.                     |
| **Events** | Messages that are emitted by steps and trigger other steps that subscribe to them.                          |
| **Topics** | Named channels or categories for events, enabling event routing and decoupling between steps.              |

## Unlock Powerful Use Cases

Motia empowers you to build a wide range of sophisticated applications, including:

- ðŸŒ **API Integrations & Microservices:**  Effortlessly connect disparate systems, create event-driven microservices, and build real-time API-powered applications.

- ðŸ¤– **Intelligent & Agentic Workflows:**  Design complex, AI-driven workflows, orchestrate intricate business processes, and build advanced data pipelines.

- ðŸ“Š **Data Transformation & Processing:**  Build scalable ETL/ELT pipelines, implement real-time data streaming, and transform data with ease.

- ðŸš€ **Rapid Prototyping & Iteration:**  Quickly bring your ideas to life, test new workflows, and iterate rapidly with Motia's visual design and development tools.

### Real-World Industry Applications

Motia is versatile and can be applied across various industries and use cases, such as:

- **E-commerce:** Order processing, inventory synchronization, fraud detection, customer communication automation.
- **Finance:** Trade settlement, risk analysis, compliance monitoring, automated reporting.
- **Healthcare:** Clinical trial management, claims processing, patient monitoring, appointment scheduling.
- **Marketing:** Lead scoring, personalized campaign orchestration, sentiment analysis, social media automation.
- **And much more!**

## Ready to Get Started?

Embark on your Motia journey and start building powerful workflows today:

1.  **Quick Start Guide:** Follow our [Quick Start](/docs/quick-start) to set up your first Motia project and create a minimal workflow.
2.  **Explore Examples:** Dive into practical [Examples](/docs/examples) to understand common patterns and real-world use cases.
3.  **Dive into Concepts:**  Delve deeper into Motia's [Core Concepts](/docs/concepts) to gain a solid understanding of the framework's architecture and principles.

## Join the Motia Community

Become part of a growing community of developers and automation enthusiasts!

- ðŸ’¬ **Join our Discord:**  Connect with the Motia team and fellow developers, ask questions, share ideas, and get real-time help: [Discord Community](https://discord.gg/motia)
- ðŸ™ **Star us on GitHub:** Show your support, contribute to the project, and report issues on our [GitHub Repository](https://github.com/motiadev/motia).
- ðŸ¦ **Follow us on Twitter:** Stay up-to-date with the latest news, announcements, and community updates: [Twitter (@motiadev)](https://twitter.com/motiadev)

We're excited to see what you'll build with Motia!

-   [index](/docs/real-world-use-cases/index.md): Documentation for index.
---
title: Real-World Use Cases
description: See how Motia is used to solve real problems
---

# Real-World Use Cases

Explore these practical examples of Motia in action:

- [Trello Card Automation](./real-world-use-cases/trello-automation) - Build an automated card progression system for Trello boards with AI-powered summaries
- More examples coming soon!

Have a great use case to share? [Contribute it here](https://github.com/MotiaDev/motia-examples/tree/main/examples). 


## Use Cases
[index](/docs/real-world-use-cases/index.md): Real world use case
---
title: Real-World Use Cases
description: See how Motia is used to solve real problems
---

# Real-World Use Cases

Explore these practical examples of Motia in action:

- [Trello Card Automation](./real-world-use-cases/trello-automation) - Build an automated card progression system for Trello boards with AI-powered summaries
- More examples coming soon!

Have a great use case to share? [Contribute it here](https://github.com/MotiaDev/motia-examples/tree/main/examples). 

-   [trello-automation](/docs/real-world-use-cases/trello-automation.md): Documentation for trello-automation.
---
title: Trello Card Automation
description: Build an automated card progression system for Trello boards with AI-powered summaries
---

## Live Example

Try out the code directly in your browser:

<CodeSandbox 
  repo="MotiaDev/motia-examples/tree/main/examples/trello-flow"
  path="/steps"
/>

## Let's build a Trello automation system that:

1. Automatically progresses cards across board lists
2. Validates card completeness
3. Generates AI-powered summaries for code review
4. Integrates with Slack for notifications
5. Monitors due dates and sends overdue alerts

## Board Structure

The Trello board is organized into four main lists:

- **New Cards**: Entry point for all new cards
- **In Progress**: Active development stage
- **Needs Review**: Code review stage with AI summaries
- **Completed**: Successfully reviewed and approved cards

## The Steps

<Folder name="steps" defaultOpen>
  <File name="trello-webhook.step.ts" />
  <File name="trello-webhook-validation.step.ts" />
  <File name="validate-card-requirements.step.ts" />
  <File name="start-assigned-card.step.ts" />
  <File name="mark-card-for-review.step.ts" />
  <File name="complete-approved-card.step.ts" />
  <File name="check-overdue-cards.step.ts" />
  <File name="slack-notifier.step.ts" />
</Folder>

<Tabs items={['webhook', 'validation', 'requirements', 'assigned', 'review', 'completion', 'overdue', 'slack']}>
  <Tab value="webhook">
    ```ts
    // Receives Trello webhook events
    import { ApiRouteConfig, StepHandler } from 'motia'
    import { z } from 'zod'

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'Trello Webhook',
      path: '/api/trello-webhook',
      method: 'POST',
      emits: ['trello.webhook'],
      bodySchema: z.object({
        action: z.object({
          type: z.string(),
          data: z.object({}).passthrough(),
        }),
      }),
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (req, { emit, logger }) => {
      const { action } = req.body

      logger.info('[TrelloWebhook] Received webhook', { 
        type: action.type,
        data: action.data 
      })

      await emit({
        topic: 'trello.webhook',
        data: action,
      })

      return {
        status: 200,
        body: { status: 'Accepted' },
      }
    }
    ```
  </Tab>
  <Tab value="validation">
    ```ts
    // Validates webhook events and routes them
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'

    const webhookSchema = z.object({
      type: z.string(),
      data: z.object({}).passthrough(),
    })

    export const config: EventConfig<typeof webhookSchema> = {
      type: 'event',
      name: 'Webhook Validator',
      subscribes: ['trello.webhook'],
      emits: [
        'trello.cardCreated',
        'trello.cardMoved',
        'trello.commentAdded',
        'trello.memberAdded'
      ],
      input: webhookSchema,
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (action, { emit, logger }) => {
      switch (action.type) {
        case 'createCard':
          await emit({
            topic: 'trello.cardCreated',
            data: action.data.card
          })
          break
        case 'updateCard':
          if (action.data.listAfter) {
            await emit({
              topic: 'trello.cardMoved',
              data: {
                card: action.data.card,
                listBefore: action.data.listBefore,
                listAfter: action.data.listAfter
              }
            })
          }
          break
        // ... other cases
      }
    }
    ```
  </Tab>
  <Tab value="requirements">
    ```ts
    // Validates new card requirements
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { TrelloClient } from '@/services/trello'

    const cardSchema = z.object({
      id: z.string(),
      name: z.string(),
      desc: z.string(),
      idMembers: z.array(z.string()),
    })

    export const config: EventConfig<typeof cardSchema> = {
      type: 'event',
      name: 'Card Requirements Validator',
      subscribes: ['trello.cardCreated'],
      emits: ['trello.cardValidated'],
      input: cardSchema,
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (card, { emit, logger }) => {
      const trello = new TrelloClient()
      
      const requirements = [
        { check: card.name.length > 0, message: 'Title is required' },
        { check: card.desc.length > 0, message: 'Description is required' },
        { check: card.idMembers.length > 0, message: 'Assignee is required' }
      ]

      const failures = requirements
        .filter(req => !req.check)
        .map(req => req.message)

      if (failures.length > 0) {
        await trello.addComment(card.id, 
          `âš ï¸ Card requirements not met:\n${failures.join('\n')}`)
        return
      }

      await emit({
        topic: 'trello.cardValidated',
        data: { cardId: card.id }
      })
    }
    ```
  </Tab>
  <Tab value="assigned">
    ```ts
    // Handles card assignment
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { TrelloClient } from '@/services/trello'

    const assignmentSchema = z.object({
      cardId: z.string(),
      memberId: z.string(),
    })

    export const config: EventConfig<typeof assignmentSchema> = {
      type: 'event',
      name: 'Card Assignment Handler',
      subscribes: ['trello.memberAdded'],
      emits: ['trello.cardStarted'],
      input: assignmentSchema,
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {
      const trello = new TrelloClient()
      
      // Move to In Progress list
      await trello.moveCard(
        input.cardId,
        process.env.TRELLO_IN_PROGRESS_LIST_ID!
      )

      await emit({
        topic: 'trello.cardStarted',
        data: { cardId: input.cardId }
      })
    }
    ```
  </Tab>
  <Tab value="review">
    ```ts
    // Handles review process
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { TrelloClient } from '@/services/trello'

    const reviewSchema = z.object({
      card: z.object({
        id: z.string(),
        name: z.string(),
      }),
      listBefore: z.object({ id: z.string() }),
      listAfter: z.object({ id: z.string() }),
    })

    export const config: EventConfig<typeof reviewSchema> = {
      type: 'event',
      name: 'Review Process Handler',
      subscribes: ['trello.cardMoved'],
      emits: ['trello.readyForReview'],
      input: reviewSchema,
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {
      // Only handle moves to review list
      if (input.listAfter.id !== process.env.TRELLO_NEEDS_REVIEW_LIST_ID) {
        return
      }

      await emit({
        topic: 'trello.readyForReview',
        data: {
          cardId: input.card.id,
          cardName: input.card.name
        }
      })
    }
    ```
  </Tab>
  <Tab value="completion">
    ```ts
    // Handles card completion
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { TrelloClient } from '@/services/trello'

    const commentSchema = z.object({
      text: z.string(),
      card: z.object({
        id: z.string(),
      }),
    })

    export const config: EventConfig<typeof commentSchema> = {
      type: 'event',
      name: 'Card Completion Handler',
      subscribes: ['trello.commentAdded'],
      emits: ['trello.cardCompleted'],
      input: commentSchema,
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {
      if (!input.text.toLowerCase().includes('approved')) {
        return
      }

      const trello = new TrelloClient()
      
      await trello.moveCard(
        input.card.id,
        process.env.TRELLO_COMPLETED_LIST_ID!
      )

      await emit({
        topic: 'trello.cardCompleted',
        data: { cardId: input.card.id }
      })
    }
    ```
  </Tab>
  <Tab value="overdue">
    ```ts
    // Checks for overdue cards
    import { CronConfig, StepHandler } from 'motia'
    import { TrelloClient } from '@/services/trello'

    export const config: CronConfig = {
      type: 'cron',
      name: 'Overdue Cards Checker',
      cron: '0 9 * * 1-5', // 9 AM on weekdays
      emits: ['trello.cardOverdue'],
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (_, { emit, logger }) => {
      const trello = new TrelloClient()
      
      const cards = await trello.getOverdueCards()
      
      for (const card of cards) {
        await emit({
          topic: 'trello.cardOverdue',
          data: {
            cardId: card.id,
            cardName: card.name,
            dueDate: card.due
          }
        })
      }
    }
    ```
  </Tab>
  <Tab value="slack">
    ```ts
    // Sends Slack notifications
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { WebClient } from '@slack/web-api'

    const slack = new WebClient(process.env.SLACK_TOKEN)

    export const config: EventConfig = {
      type: 'event',
      name: 'Slack Notifier',
      subscribes: [
        'trello.readyForReview',
        'trello.cardCompleted',
        'trello.cardOverdue'
      ],
      emits: [],
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (event, { logger }) => {
      switch (event.type) {
        case 'trello.readyForReview':
          await slack.chat.postMessage({
            channel: '#code-review',
            text: `ðŸ” New review needed: ${event.data.cardName}`,
            blocks: [
              {
                type: 'section',
                text: {
                  type: 'mrkdwn',
                  text: `ðŸ” *New review needed*\n${event.data.cardName}`
                }
              }
            ]
          })
          break
        // ... handle other events
      }
    }
    ```
  </Tab>
</Tabs>

## Visual Overview

Here's how the automation flow works:

<div className="my-8">
  ![Flow: Trello Automation Steps](../img/trello-automation.png)
</div>

1. **Card Validation** â†’ Checks for required information
2. **Progress Tracking** â†’ Moves cards between lists
3. **Review Process** â†’ Generates AI summaries and notifies reviewers
4. **Completion Handling** â†’ Processes approved cards

## Try It Out

<Steps>

### Prerequisites

Make sure you have:
- Trello account with API access
- Node.js installed
- Slack workspace (for notifications)
- OpenAI API key (for AI summaries)

### Clone the Repository

```bash
git clone git@github.com:MotiaDev/Ytallo-Challenge.git
cd Ytallo-Challenge
```

### Install Dependencies

```bash
pnpm install
```

### Configure Environment Variables

Create a `.env` file by copying the example:

```bash
cp .env.example .env
```

Update your `.env` with the following credentials:

```env
TRELLO_API_KEY=your_trello_api_key
TRELLO_TOKEN=your_trello_token

OPENAI_API_KEY=your_openai_api_key
OPENAI_MODEL=your_openai_model

SLACK_WEBHOOK_URL=your_slack_webhook_url

TRELLO_NEW_TASKS_LIST_ID=your_new_tasks_list_id
TRELLO_IN_PROGRESS_LIST_ID=your_in_progress_list_id
TRELLO_NEEDS_REVIEW_LIST_ID=your_needs_review_list_id
TRELLO_COMPLETED_LIST_ID=your_completed_list_id
```

### Set Up Trello Board

1. Create a new Trello board with these lists:
   - New Tasks
   - In Progress
   - Needs Review
   - Completed

2. Add a custom field:
   - Status (dropdown: Todo, In Progress, Done)

### Run the Application

```bash
pnpm dev
```

### Test the Flow

1. Create a new card in the "New Tasks" list
2. Assign a member to see it move to "In Progress"
3. Add an "approved" comment to see it move to "Completed"
4. Check Slack for notifications

</Steps>

<Callout type="info">
  For more detailed setup instructions and configuration options, check out the [full documentation](https://github.com/MotiaDev/motia-examples/tree/main/examples/trello-flow).
</Callout> 


## Use Cases
[trello-automation](/docs/real-world-use-cases/trello-automation.md): Real world use case
---
title: Trello Card Automation
description: Build an automated card progression system for Trello boards with AI-powered summaries
---

## Live Example

Try out the code directly in your browser:

<CodeSandbox 
  repo="MotiaDev/motia-examples/tree/main/examples/trello-flow"
  path="/steps"
/>

## Let's build a Trello automation system that:

1. Automatically progresses cards across board lists
2. Validates card completeness
3. Generates AI-powered summaries for code review
4. Integrates with Slack for notifications
5. Monitors due dates and sends overdue alerts

## Board Structure

The Trello board is organized into four main lists:

- **New Cards**: Entry point for all new cards
- **In Progress**: Active development stage
- **Needs Review**: Code review stage with AI summaries
- **Completed**: Successfully reviewed and approved cards

## The Steps

<Folder name="steps" defaultOpen>
  <File name="trello-webhook.step.ts" />
  <File name="trello-webhook-validation.step.ts" />
  <File name="validate-card-requirements.step.ts" />
  <File name="start-assigned-card.step.ts" />
  <File name="mark-card-for-review.step.ts" />
  <File name="complete-approved-card.step.ts" />
  <File name="check-overdue-cards.step.ts" />
  <File name="slack-notifier.step.ts" />
</Folder>

<Tabs items={['webhook', 'validation', 'requirements', 'assigned', 'review', 'completion', 'overdue', 'slack']}>
  <Tab value="webhook">
    ```ts
    // Receives Trello webhook events
    import { ApiRouteConfig, StepHandler } from 'motia'
    import { z } from 'zod'

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'Trello Webhook',
      path: '/api/trello-webhook',
      method: 'POST',
      emits: ['trello.webhook'],
      bodySchema: z.object({
        action: z.object({
          type: z.string(),
          data: z.object({}).passthrough(),
        }),
      }),
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (req, { emit, logger }) => {
      const { action } = req.body

      logger.info('[TrelloWebhook] Received webhook', { 
        type: action.type,
        data: action.data 
      })

      await emit({
        topic: 'trello.webhook',
        data: action,
      })

      return {
        status: 200,
        body: { status: 'Accepted' },
      }
    }
    ```
  </Tab>
  <Tab value="validation">
    ```ts
    // Validates webhook events and routes them
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'

    const webhookSchema = z.object({
      type: z.string(),
      data: z.object({}).passthrough(),
    })

    export const config: EventConfig<typeof webhookSchema> = {
      type: 'event',
      name: 'Webhook Validator',
      subscribes: ['trello.webhook'],
      emits: [
        'trello.cardCreated',
        'trello.cardMoved',
        'trello.commentAdded',
        'trello.memberAdded'
      ],
      input: webhookSchema,
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (action, { emit, logger }) => {
      switch (action.type) {
        case 'createCard':
          await emit({
            topic: 'trello.cardCreated',
            data: action.data.card
          })
          break
        case 'updateCard':
          if (action.data.listAfter) {
            await emit({
              topic: 'trello.cardMoved',
              data: {
                card: action.data.card,
                listBefore: action.data.listBefore,
                listAfter: action.data.listAfter
              }
            })
          }
          break
        // ... other cases
      }
    }
    ```
  </Tab>
  <Tab value="requirements">
    ```ts
    // Validates new card requirements
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { TrelloClient } from '@/services/trello'

    const cardSchema = z.object({
      id: z.string(),
      name: z.string(),
      desc: z.string(),
      idMembers: z.array(z.string()),
    })

    export const config: EventConfig<typeof cardSchema> = {
      type: 'event',
      name: 'Card Requirements Validator',
      subscribes: ['trello.cardCreated'],
      emits: ['trello.cardValidated'],
      input: cardSchema,
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (card, { emit, logger }) => {
      const trello = new TrelloClient()
      
      const requirements = [
        { check: card.name.length > 0, message: 'Title is required' },
        { check: card.desc.length > 0, message: 'Description is required' },
        { check: card.idMembers.length > 0, message: 'Assignee is required' }
      ]

      const failures = requirements
        .filter(req => !req.check)
        .map(req => req.message)

      if (failures.length > 0) {
        await trello.addComment(card.id, 
          `âš ï¸ Card requirements not met:\n${failures.join('\n')}`)
        return
      }

      await emit({
        topic: 'trello.cardValidated',
        data: { cardId: card.id }
      })
    }
    ```
  </Tab>
  <Tab value="assigned">
    ```ts
    // Handles card assignment
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { TrelloClient } from '@/services/trello'

    const assignmentSchema = z.object({
      cardId: z.string(),
      memberId: z.string(),
    })

    export const config: EventConfig<typeof assignmentSchema> = {
      type: 'event',
      name: 'Card Assignment Handler',
      subscribes: ['trello.memberAdded'],
      emits: ['trello.cardStarted'],
      input: assignmentSchema,
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {
      const trello = new TrelloClient()
      
      // Move to In Progress list
      await trello.moveCard(
        input.cardId,
        process.env.TRELLO_IN_PROGRESS_LIST_ID!
      )

      await emit({
        topic: 'trello.cardStarted',
        data: { cardId: input.cardId }
      })
    }
    ```
  </Tab>
  <Tab value="review">
    ```ts
    // Handles review process
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { TrelloClient } from '@/services/trello'

    const reviewSchema = z.object({
      card: z.object({
        id: z.string(),
        name: z.string(),
      }),
      listBefore: z.object({ id: z.string() }),
      listAfter: z.object({ id: z.string() }),
    })

    export const config: EventConfig<typeof reviewSchema> = {
      type: 'event',
      name: 'Review Process Handler',
      subscribes: ['trello.cardMoved'],
      emits: ['trello.readyForReview'],
      input: reviewSchema,
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {
      // Only handle moves to review list
      if (input.listAfter.id !== process.env.TRELLO_NEEDS_REVIEW_LIST_ID) {
        return
      }

      await emit({
        topic: 'trello.readyForReview',
        data: {
          cardId: input.card.id,
          cardName: input.card.name
        }
      })
    }
    ```
  </Tab>
  <Tab value="completion">
    ```ts
    // Handles card completion
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { TrelloClient } from '@/services/trello'

    const commentSchema = z.object({
      text: z.string(),
      card: z.object({
        id: z.string(),
      }),
    })

    export const config: EventConfig<typeof commentSchema> = {
      type: 'event',
      name: 'Card Completion Handler',
      subscribes: ['trello.commentAdded'],
      emits: ['trello.cardCompleted'],
      input: commentSchema,
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {
      if (!input.text.toLowerCase().includes('approved')) {
        return
      }

      const trello = new TrelloClient()
      
      await trello.moveCard(
        input.card.id,
        process.env.TRELLO_COMPLETED_LIST_ID!
      )

      await emit({
        topic: 'trello.cardCompleted',
        data: { cardId: input.card.id }
      })
    }
    ```
  </Tab>
  <Tab value="overdue">
    ```ts
    // Checks for overdue cards
    import { CronConfig, StepHandler } from 'motia'
    import { TrelloClient } from '@/services/trello'

    export const config: CronConfig = {
      type: 'cron',
      name: 'Overdue Cards Checker',
      cron: '0 9 * * 1-5', // 9 AM on weekdays
      emits: ['trello.cardOverdue'],
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (_, { emit, logger }) => {
      const trello = new TrelloClient()
      
      const cards = await trello.getOverdueCards()
      
      for (const card of cards) {
        await emit({
          topic: 'trello.cardOverdue',
          data: {
            cardId: card.id,
            cardName: card.name,
            dueDate: card.due
          }
        })
      }
    }
    ```
  </Tab>
  <Tab value="slack">
    ```ts
    // Sends Slack notifications
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { WebClient } from '@slack/web-api'

    const slack = new WebClient(process.env.SLACK_TOKEN)

    export const config: EventConfig = {
      type: 'event',
      name: 'Slack Notifier',
      subscribes: [
        'trello.readyForReview',
        'trello.cardCompleted',
        'trello.cardOverdue'
      ],
      emits: [],
      flows: ['trello-automation'],
    }

    export const handler: StepHandler<typeof config> = async (event, { logger }) => {
      switch (event.type) {
        case 'trello.readyForReview':
          await slack.chat.postMessage({
            channel: '#code-review',
            text: `ðŸ” New review needed: ${event.data.cardName}`,
            blocks: [
              {
                type: 'section',
                text: {
                  type: 'mrkdwn',
                  text: `ðŸ” *New review needed*\n${event.data.cardName}`
                }
              }
            ]
          })
          break
        // ... handle other events
      }
    }
    ```
  </Tab>
</Tabs>

## Visual Overview

Here's how the automation flow works:

<div className="my-8">
  ![Flow: Trello Automation Steps](../img/trello-automation.png)
</div>

1. **Card Validation** â†’ Checks for required information
2. **Progress Tracking** â†’ Moves cards between lists
3. **Review Process** â†’ Generates AI summaries and notifies reviewers
4. **Completion Handling** â†’ Processes approved cards

## Try It Out

<Steps>

### Prerequisites

Make sure you have:
- Trello account with API access
- Node.js installed
- Slack workspace (for notifications)
- OpenAI API key (for AI summaries)

### Clone the Repository

```bash
git clone git@github.com:MotiaDev/Ytallo-Challenge.git
cd Ytallo-Challenge
```

### Install Dependencies

```bash
pnpm install
```

### Configure Environment Variables

Create a `.env` file by copying the example:

```bash
cp .env.example .env
```

Update your `.env` with the following credentials:

```env
TRELLO_API_KEY=your_trello_api_key
TRELLO_TOKEN=your_trello_token

OPENAI_API_KEY=your_openai_api_key
OPENAI_MODEL=your_openai_model

SLACK_WEBHOOK_URL=your_slack_webhook_url

TRELLO_NEW_TASKS_LIST_ID=your_new_tasks_list_id
TRELLO_IN_PROGRESS_LIST_ID=your_in_progress_list_id
TRELLO_NEEDS_REVIEW_LIST_ID=your_needs_review_list_id
TRELLO_COMPLETED_LIST_ID=your_completed_list_id
```

### Set Up Trello Board

1. Create a new Trello board with these lists:
   - New Tasks
   - In Progress
   - Needs Review
   - Completed

2. Add a custom field:
   - Status (dropdown: Todo, In Progress, Done)

### Run the Application

```bash
pnpm dev
```

### Test the Flow

1. Create a new card in the "New Tasks" list
2. Assign a member to see it move to "In Progress"
3. Add an "approved" comment to see it move to "Completed"
4. Check Slack for notifications

</Steps>

<Callout type="info">
  For more detailed setup instructions and configuration options, check out the [full documentation](https://github.com/MotiaDev/motia-examples/tree/main/examples/trello-flow).
</Callout> 

-   [welcome](/docs/welcome.md): Documentation for welcome.
---
title: Welcome to Motia
description: Get started with Motia, a powerful framework for building event-driven workflows
---

# Code-First Framework for Intelligent Workflows

Motia is a **code-first framework** designed to empower developers to build robust, scalable, and observable event-driven workflows with unparalleled ease. We handle the infrastructure complexities, so you can focus on your business logic.

## Why Choose Motia?

Motia is built with the developer in mind, offering a unique blend of simplicity and power. Here's why Motia stands out:

- ðŸš€ **Zero Infrastructure Setup:** Say goodbye to the complexities of message queues and event brokers! Motia handles the underlying infrastructure, allowing you to focus solely on building your workflows.

- ðŸ”Œ **Plug-and-Play Steps in Your Language:**  Develop your workflow logic using the languages you love: JavaScript, TypeScript, Python, and Ruby. Mix and match languages within the same flow for ultimate flexibility.

- ðŸ“Š **Built-in Observability:** Gain deep insights into your workflows with real-time logs, traces, and interactive flow visualizations right in the Motia Workbench. Debugging and monitoring have never been easier.

- âš¡ **Out-of-the-Box API & Scheduling:**  Instantly expose your workflows as HTTP endpoints and schedule tasks with cron expressions â€“ no extra configuration needed.

- âœ¨ **Flexible and Extensible Architecture:**  Motia is designed to be easily extended and customized. Create custom steps, UI components, and adapt the framework to your specific needs.

- ðŸ§‘â€ðŸ’» **Developer-First Experience:**  From intuitive APIs and a powerful CLI to comprehensive documentation and a visual workbench, Motia prioritizes developer productivity and a smooth, enjoyable development experience.

## Motia Workbench: Your Development Control Center

Motia Workbench is a built-in, browser-based development platform that acts as your central hub for building, testing, and debugging Motia flows. Key features include:

- **Interactive Flow Visualization:**  See your workflows come to life as dynamic diagrams, making it easy to understand complex event flows and step interactions.

- **Real-time Flow Testing:**  Trigger API endpoints and monitor event propagation through your steps, all within the Workbench UI. Inspect data at each stage to ensure your flows are behaving as expected.

- **Live Log Streaming:**  Access detailed, real-time logs directly in the Workbench. Filter and search logs to quickly pinpoint issues and monitor workflow execution.

- **Step-Level Customization:**  Create custom UI components for your steps to enhance visualization and provide context-specific information directly within the flow diagram.

<div className="my-8">
  ![Motia Workbench Interface](./img/workbench-presentation.png)
</div>

## Core Concepts: Building Blocks of Motia

Motia workflows are built using a few core concepts that work together harmoniously:

| Concept    | Description                                                                                                |
| ---------- | ---------------------------------------------------------------------------------------------------------- |
| **Steps**  | Self-contained, reusable units of business logic. Steps subscribe to events, process data, and emit events. |
| **Flows**  | Logical groupings of related steps that together accomplish a specific task or process.                     |
| **Events** | Messages that are emitted by steps and trigger other steps that subscribe to them.                          |
| **Topics** | Named channels or categories for events, enabling event routing and decoupling between steps.              |

## Unlock Powerful Use Cases

Motia empowers you to build a wide range of sophisticated applications, including:

- ðŸŒ **API Integrations & Microservices:**  Effortlessly connect disparate systems, create event-driven microservices, and build real-time API-powered applications.

- ðŸ¤– **Intelligent & Agentic Workflows:**  Design complex, AI-driven workflows, orchestrate intricate business processes, and build advanced data pipelines.

- ðŸ“Š **Data Transformation & Processing:**  Build scalable ETL/ELT pipelines, implement real-time data streaming, and transform data with ease.

- ðŸš€ **Rapid Prototyping & Iteration:**  Quickly bring your ideas to life, test new workflows, and iterate rapidly with Motia's visual design and development tools.

### Real-World Industry Applications

Motia is versatile and can be applied across various industries and use cases, such as:

- **E-commerce:** Order processing, inventory synchronization, fraud detection, customer communication automation.
- **Finance:** Trade settlement, risk analysis, compliance monitoring, automated reporting.
- **Healthcare:** Clinical trial management, claims processing, patient monitoring, appointment scheduling.
- **Marketing:** Lead scoring, personalized campaign orchestration, sentiment analysis, social media automation.
- **And much more!**

## Ready to Get Started?

Embark on your Motia journey and start building powerful workflows today:

1.  **Quick Start Guide:** Follow our [Quick Start](/docs/quick-start) to set up your first Motia project and create a minimal workflow.
2.  **Explore Examples:** Dive into practical [Examples](/docs/examples) to understand common patterns and real-world use cases.
3.  **Dive into Concepts:**  Delve deeper into Motia's [Core Concepts](/docs/concepts) to gain a solid understanding of the framework's architecture and principles.

## Join the Motia Community

Become part of a growing community of developers and automation enthusiasts!

- ðŸ’¬ **Join our Discord:**  Connect with the Motia team and fellow developers, ask questions, share ideas, and get real-time help: [Discord Community](https://discord.gg/motia)
- ðŸ™ **Star us on GitHub:** Show your support, contribute to the project, and report issues on our [GitHub Repository](https://github.com/motiadev/motia).
- ðŸ¦ **Follow us on Twitter:** Stay up-to-date with the latest news, announcements, and community updates: [Twitter (@motiadev)](https://twitter.com/motiadev)

We're excited to see what you'll build with Motia!

-   [NOOP Steps](/docs/workbench/noop-steps.md): Documentation for NOOP Steps.
---
title: NOOP Steps
---

NOOP (No Operation) steps are a powerful feature in Motia that serve multiple purposes:

1. Modeling external processes, webhooks and integrations
2. Representing human-in-the-loop activities
3. Creating custom visualizations in the workbench
4. Testing flows during development

<Callout type="warn">Currently, NOOP steps are only supported in TS or JS</Callout>

## Representing External Processes

NOOP steps represent parts of your workflow that happen outside your system. Common examples include:

### Webhook Callbacks

<Tabs  items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
    export const config: NoopConfig = {
      type: 'noop',
      name: 'Wait for Stripe Webhook',
      description: 'Waits for payment confirmation',
      virtualSubscribes: ['payment.initiated'],
      virtualEmits: ['/api/stripe/webhook'],
      flows: ['payment'],
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    const config = {
      type: 'noop',
      name: 'Wait for Stripe Webhook',
      description: 'Waits for payment confirmation',
      virtualSubscribes: ['payment.initiated'],
      virtualEmits: ['/api/stripe/webhook'],
      flows: ['payment'],
    }
    ```
  </Tab>
</Tabs>

### Human Approvals

<Tabs  items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
    export const config: NoopConfig = {
      type: 'noop',
  name: 'Manager Review',
  description: 'Manager reviews request',
  virtualSubscribes: ['approval.requested'],
      virtualEmits: ['/api/approvals/submit'],
      flows: ['approval'],
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    const config = {
      type: 'noop',
      name: 'Manager Review',
      description: 'Manager reviews request',
      virtualSubscribes: ['approval.requested'],
      virtualEmits: ['/api/approvals/submit'],
      flows: ['approval'],
    }
    ```
  </Tab>
</Tabs>

### External System Integration

<Tabs  items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
      export const config: NoopConfig = {
        type: 'noop',
        name: 'GitHub Webhook',
        description: 'Waiting for repository events',
        virtualSubscribes: ['repository.watched'],
        virtualEmits: ['/api/github/webhook'],
        flows: ['repo-automation'],
      }
      ```
  </Tab>
  <Tab value="JS">
    ```javascript
    const config = {
      type: 'noop',
      name: 'GitHub Webhook',
      description: 'Waiting for repository events',
      virtualSubscribes: ['repository.watched'],
      virtualEmits: ['/api/github/webhook'],
      flows: ['repo-automation'],
    }
    ```
  </Tab>
</Tabs>

### Physical Processes

<Tabs  items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
    export const config: NoopConfig = {
      type: 'noop',
      name: 'Order Fulfillment',
      description: 'Warehouse processes order',
      virtualSubscribes: ['order.placed'],
      virtualEmits: ['/api/warehouse/status'],
      flows: ['fulfillment'],
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    const config = {
      type: 'noop',
      name: 'Order Fulfillment',
      description: 'Warehouse processes order',
      virtualSubscribes: ['order.placed'],
      virtualEmits: ['/api/warehouse/status'],
      flows: ['fulfillment'],
    }
    ```
  </Tab>
</Tabs>

## Visualization in Workbench

NOOP steps are visually represented in the Motia Workbench with the following characteristics:

- Distinct node representation with clear input/output handles
- Visual indicators for virtual event connections
- Status indicators for waiting states
- Clear visualization of external system dependencies

## Custom UI

You can enhance your NOOP steps with custom React components for better visualization:

<Tabs  items={['TS', 'JS']}>
  <Tab value="TS">
    ```tsx
    // customNode.step.tsx
    import React from 'react'
    import { BaseHandle, EventNodeProps, Position } from '@motiadev/workbench'

    export default (_: EventNodeProps) => {
      return (
        <div className="p-3 px-6 flex flex-col max-w-[300px] bg-blue-500 border-white rounded-full text-white border border-solid text-center text-sm">
          <div>Custom Processing</div>
          <BaseHandle type="target" position={Position.Top} />
          <BaseHandle type="source" position={Position.Bottom} />
        </div>
      )
    }

    // customNode.step.ts
    export const config: NoopConfig = {
      type: 'noop',
      name: 'Custom Process',
      virtualEmits: ['/api/process/complete'],
      virtualSubscribes: ['process.start'],
      flows: ['custom-flow']
    }
    ```
  </Tab>
  <Tab value="JS">
    ```jsx
    // customNode.step.jsx
    import React from 'react'
    import { BaseHandle, EventNodeProps, Position } from '@motiadev/workbench'

    export default (_: EventNodeProps) => {
      return (
        <div className="p-3 px-6 flex flex-col max-w-[300px] bg-blue-500 border-white rounded-full text-white border border-solid text-center text-sm">
          <div>Custom Processing</div>
          <BaseHandle type="target" position={Position.Top} />
          <BaseHandle type="source" position={Position.Bottom} />
        </div>
      )
    }

    // customNode.step.js
    const config = {
      type: 'noop',
      name: 'Custom Process',
      virtualEmits: ['/api/process/complete'],
      virtualSubscribes: ['process.start'],
      flows: ['custom-flow']
    }

    module.exports = {config};
    ```
  </Tab>
</Tabs>

## Best Practices

| Category | Guidelines |
|----------|------------|
| **External Process Modeling** | â€¢ Use descriptive, action-oriented names<br/>â€¢ Document expected timeframes and SLAs<br/>â€¢ Define all possible outcomes and edge cases<br/>â€¢ Use exact API route matching |
| **UI Components** | â€¢ Leverage Tailwind's utility classes<br/>â€¢ Keep components minimal and focused<br/>â€¢ Design clear visual connection points<br/>â€¢ Maintain consistent styling patterns |
| **Testing** | â€¢ Create isolated test flows<br/>â€¢ Implement clear status indicators<br/>â€¢ Label test steps explicitly<br/>â€¢ Document test scenarios and procedures |

## Component Reference

### Core Imports

| Import | Purpose |
|--------|---------|
| `BaseHandle` | A React component that renders connection points for nodes in the workflow. Used to define where edges (connections) can start or end on a node. |
| `EventNodeProps` | (TypeScript only) Interface defining the properties passed to node components, including node data, selected state, and connection information. |
| `Position` | (TypeScript only) Enum that specifies the possible positions for handles on a node (Top, Right, Bottom, Left). Used to control where connection points appear. |

### Handle Placement

| Handle Type | Position | 
|------------|----------|
| Input Handles | Position.Top |
| Output Handles | Position.Bottom |
| Flow Direction | Top to bottom |

### Styling Guidelines

| Category | Guidelines |
|----------|------------|
| Colors | Use semantic colors to indicate state (success, error, pending) |
| Typography | â€¢ Ensure high contrast for readability<br/>â€¢ Use consistent font sizes (recommended: 14px-16px) |
| States | â€¢ Implement clear visual indicators for active/inactive states<br/>â€¢ Use subtle animations for state transitions |
| Design System | â€¢ Follow your project's design tokens<br/>â€¢ Maintain consistent spacing and padding<br/>â€¢ Use standard border radiuses |


-   [Overview](/docs/workbench/overview.md): Documentation for Overview.
---
title: Overview
---

Motia Workbench is a development platform that helps you build and debug your Motia flows. It serves as your control center where you can:

- Visualize flows as interactive diagrams
- Test steps directly in the UI
- Monitor real-time logs
- Debug issues

![Flow Visualization in Workbench](./../img/demo-workbench.png)

## Getting Started

Start workbench by running:

<Tabs items={['pnpm', 'yarn', 'npm', 'bun']}>
   <Tab value='pnpm'>
   ```bash
   pnpm run dev
   ```
   </Tab>
   <Tab value='yarn'>
   ```bash
   yarn run dev
   ```
   </Tab>
   <Tab value='npm'>
   ```bash
   npm run dev
   ```
   </Tab>
   <Tab value='bun'>
   ```bash
   bun run dev
   ```
   </Tab>
</Tabs>

<Callout>
Running the dev command starts:
- **Motia Server**: Backend services and API endpoints
- **Motia Workbench**: Web interface at http://localhost:3000
- **Development Mode**: Auto-reloads when changes are made
</Callout>

## Key Features

<Steps>
  <Step>
  ### Flow Visualization
  See your entire flow as an interactive diagram:
  - Steps appear as connected nodes
  - API endpoints are highlighted as entry points
  - Event connections show data flow
  - Click any step to see its details
  </Step>

  <Step>
  ### Real-time Testing
  Test your flows directly in the interface:
  - Send test requests to API endpoints
  - Monitor how events flow through steps
  - Visualize step sequence execution
  - Inspect data at each stage
  </Step>

  <Step>
  ### Live Logs
  Monitor your flow execution:
  ```
  [INFO] [payment-flow] Payment received: $50.00
  [DEBUG] [payment-flow] Processing payment...
  ```
  </Step>

  <Step>
   ### Development Tools
  - **Hot Reload**: Changes reflect immediately in the UI
  - **Error Handling**: Detailed error messages with contextual debugging information
  - **State Inspector**: Real-time monitoring of state management
  </Step>
</Steps>

## Customization

Motia Workbench allows you to customize how your steps appear in the Workbench flow visualization tool.

### NOOP Steps

NOOP (No Operation) steps represent virtual points in your flow where external actions occur:
- Human approvals or reviews
- Webhook callbacks
- External system integrations
- Manual interventions

These steps help visualize important external touchpoints without implementing actual logic.

### UI Steps

UI steps allow you to customize how your steps appear in the Workbench visualization:
- Override the default layout of Event steps
- Customize API endpoint representations
- Modify how Cron jobs are displayed
- Add custom icons and styling

<Breadcrumb items={[{
  name: 'UI Steps',
  url: '/docs/workbench/ui-steps'
},{
  name: 'NOOP Steps',
  url: '/docs/workbench/noop-steps'
}]} />

<Callout>
New to Motia? Follow the **[quick start](/docs/quick-start)** guide to get set up.
</Callout>



-   [UI Steps](/docs/workbench/ui-steps.md): Documentation for UI Steps.
---
title: UI Steps
---

UI Steps provide a powerful way to create custom, visually appealing representations of your workflow steps in the Workbench flow visualization tool. 

With UI Steps, you can enhance the user experience by designing intuitive, context-aware visual components that clearly communicate your flow's sequencing and events.

<Callout type="warn">Currently, UI steps are only supported in TypeScript and JavaScript</Callout>

## Overview

To create a custom UI for a step, create a `.tsx` or `.jsx` file next to your step file with the same base name:

<Tabs items={['tsx', 'jsx']}>
  <Tab value="tsx">
    ```
    steps/
      â””â”€â”€ myStep/
      â”œâ”€â”€ myStep.step.ts      # Step definition
      â””â”€â”€ myStep.step.tsx     # Visual override
    ```
  </Tab>
  <Tab value="jsx">
    ```
    steps/
      â””â”€â”€ myStep/
      â”œâ”€â”€ myStep.step.js      # Step definition
      â””â”€â”€ myStep.step.jsx     # Visual override
    ```
  </Tab>
</Tabs>

## Basic Usage

<Tabs items={['TypeScript', 'JavaScript']}>
  <Tab>
    ```typescript
    // myStep.step.tsx

    import React from 'react'
    import { EventNode } from '@motiadev/workbench'
    import type { EventNodeProps } from '@motiadev/workbench'

    export default function MyStep({ data }: EventNodeProps) {
      return (
        <EventNode
          data={data}
          variant="white"
          className="py-2 px-4"
        />
      )
    }
    ```
  </Tab>
  <Tab>
    ```javascript
    // myStep.step.jsx

    import React from 'react'
    import { EventNode } from '@motiadev/workbench'

    export default function MyStep({ data }) {
      return (
        <EventNode
          data={data}
          variant="white"
          className="py-2 px-4"
        />
      )
    }
    ```
  </Tab>
</Tabs>

## Components

Motia Workbench provides out of the box components that you can use to create custom UI steps, which apply to different types of steps.

### EventNode

The main component for general-purpose steps.

| Prop | Type | Description |
|------|------|-------------|
| data | `EventNodeProps['data']` | Step data passed from Workbench |
| variant | `'white' \| 'ghost' \| 'noop'` | Visual style variant |
| shape | `'rounded' \| 'square' \| 'noop'` | Node shape style |
| className | `string` | Additional CSS classes |

<Tabs items={['TypeScript', 'JavaScript']}>
  <Tab>
    ```typescript
    // customStep.step.tsx

    import React from 'react'
    import { EventNode } from '@motiadev/workbench'
    import type { EventNodeProps } from '@motiadev/workbench'

    export default function CustomStep({ data }: EventNodeProps) {
      return (
        <EventNode
          data={data}
          variant="white"
          shape="rounded"
          className="py-2 px-4"
        >
          <div>Custom content</div>
        </EventNode>
      )
    }
    ```
  </Tab>
  <Tab>
    ```javascript
    // customStep.step.jsx

    import React from 'react'
    import { EventNode } from '@motiadev/workbench'

    export default function CustomStep({ data }) {
      return (
        <EventNode
          data={data}
          variant="white"
          shape="rounded"
          className="py-2 px-4"
        >
          <div>Custom content</div>
        </EventNode>
      )
    }
    ```
  </Tab>
</Tabs>

<Callout type="info">
The `EventNodeProps` type provides essential information about your step. Here are the key properties:

| Property | Type | Description |
|----------|------|-------------|
| type | `string` | The type of the step |
| name | `string` | The name of the step |
| description | `string` | A detailed description of the step |
| subscribes | `string[]` | List of topics this step listens to |
| emits | `string[]` | List of topics this step emits |
| language | `string` | The programming language used |

</Callout>

### ApiNode

Specialized component for API-related steps.

| Prop | Type | Description |
|------|------|-------------|
| data | `ApiNodeProps['data']` | API step data |
| className | `string` | Additional CSS classes |

<Tabs items={['TypeScript', 'JavaScript']}>
  <Tab>
    ```typescript
    // apiStep.step.tsx

    import React from 'react'
    import { ApiNode } from '@motiadev/workbench'
    import type { ApiNodeProps } from '@motiadev/workbench'

    export default function ApiStep({ data }: ApiNodeProps) {
      return (
        <ApiNode
          data={data}
          className="border-blue-500"
        >
          <div>API endpoint: {data.name}</div>
        </ApiNode>
      )
    }
    ```
  </Tab>
  <Tab>
    ```javascript
    // apiStep.step.jsx

    import React from 'react'
    import { ApiNode } from '@motiadev/workbench'

    export default function ApiStep({ data }) {
      return (
        <ApiNode
          data={data}
          className="border-blue-500"
        >
          <div>API endpoint: {data.name}</div>
        </ApiNode>
      )
    }
    ```
  </Tab>
</Tabs>

<Callout type="info">
The `ApiNodeProps` type provides essential information about your step. Here are the key properties:

| Property | Type | Description |
|----------|------|-------------|
| type | `string` | The type of the step |
| name | `string` | The name of the step |
| description | `string` | A detailed description of the step |
| emits | `string[]` | List of topics this step emits |
| subscribes | `string[]` | List of topics this step listens to |
| webhookUrl | `string` | The URL of the webhook |
| bodySchema | `JSONSchema7` | The schema of the body of the request |

</Callout>

## Styling Guidelines

| Guideline | Description |
|-----------|-------------|
| Use Tailwind's utility classes only | Stick to Tailwind CSS utilities for consistent styling |
| Avoid arbitrary values | Use predefined scales from the design system |
| Keep components responsive | Ensure UI elements adapt well to different screen sizes |
| Follow Motia's design system | Maintain consistency with Motia's established design patterns |

<Callout type="info">
  Custom styles should be minimal and consistent with the overall Workbench UI.
</Callout>

## Best Practices

| Practice | Description |
|----------|-------------|
| Use base components | Use `EventNode` and `ApiNode` when possible |
| Keep it simple | Maintain simple and clear visualizations |
| Optimize performance | Minimize state and computations |
| Documentation | Document custom components and patterns |
| Style sharing | Share common styles through utility classes |



## Optional
-   [https://motiadev.com](https://motiadev.com): Main page for framework.
-   [Github repo](https://github.com/motiadev/motia): Main github repository to file issues.
